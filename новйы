#!/usr/bin/env python3
"""
–û–±—ä–µ–¥–∏–Ω–µ–Ω–Ω—ã–π —Å–∫—Ä–∏–ø—Ç:
1) –ë—ã—Å—Ç—Ä—ã–π –ø–æ–∏—Å–∫ –ª—é–±–æ–≥–æ –∞–∫–∫–∞—É–Ω—Ç–∞ –ø–æ —Ü–µ–ª–µ–≤–æ–π –¥–∞—Ç–µ (–ª–æ–≥–∏–∫–∞ 1.py).
2) –ë–∏–Ω–∞—Ä–Ω—ã–π –ø–æ–∏—Å–∫ –≥—Ä–∞–Ω–∏—Ü –≤—Å–µ—Ö –∞–∫–∫–∞—É–Ω—Ç–æ–≤ –∑–∞ –¥–µ–Ω—å (–ª–æ–≥–∏–∫–∞ 2v2.py).
3) –£–º–Ω—ã–π –ø–µ—Ä–µ–±–æ—Ä —ç—Ç–∏—Ö –∞–∫–∫–∞—É–Ω—Ç–æ–≤ –∏ –ø–æ–∏—Å–∫ –ø–æ –∏–º–µ–Ω–∏ (–ª–æ–≥–∏–∫–∞ 3neu.py).
"""

import json
import logging
import random
import re
import signal
import sys
import threading
import time
from collections import defaultdict
from concurrent.futures import ThreadPoolExecutor, as_completed
from dataclasses import dataclass
from datetime import datetime
from typing import Dict, Optional, Tuple

import requests

STOP_EVENT = threading.Event()
LAST_SEARCH = None
ERROR_NOTIFY_SENT = False
ERROR_STOP_THRESHOLD = 100
COOLDOWN_UNTIL = 0.0
COOLDOWN_LOCK = threading.Lock()
SOFT_START_UNTIL = 0.0
SOFT_START_RPS = 5


def request_stop() -> None:
    STOP_EVENT.set()


def reset_stop() -> None:
    STOP_EVENT.clear()


def reset_error_state() -> None:
    global ERROR_NOTIFY_SENT
    ERROR_NOTIFY_SENT = False


def stop_requested() -> bool:
    return STOP_EVENT.is_set()


def set_soft_start(duration_seconds: int = 180) -> None:
    global SOFT_START_UNTIL
    SOFT_START_UNTIL = time.time() + duration_seconds


def soft_start_active() -> bool:
    return time.time() < SOFT_START_UNTIL


def get_effective_rps(base_rps: int) -> int:
    if soft_start_active():
        return min(base_rps, SOFT_START_RPS)
    return base_rps


def set_cooldown(seconds: int, reason: str) -> None:
    global COOLDOWN_UNTIL
    if seconds <= 0:
        return
    now = time.time()
    with COOLDOWN_LOCK:
        COOLDOWN_UNTIL = max(COOLDOWN_UNTIL, now + seconds)
        remaining = int(COOLDOWN_UNTIL - now)
    minutes = max(1, int((remaining + 59) / 60))
    notify(
        "–î–∞–π –æ—Ç–¥–æ—Ö–Ω—É—Ç—å –±–æ—Ç—É "
        f"{minutes} –º–∏–Ω—É—Ç. {reason}\n"
        "–ü—Ä–∏–¥–µ—Ç —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–µ –∫–æ–≥–¥–∞ –æ–Ω –æ—Ç–ª–µ–∂–∏—Ç—Å—è."
    )

    def _cooldown_waiter(target_time: float, reason_text: str) -> None:
        sleep_for = max(0, target_time - time.time())
        if sleep_for:
            time.sleep(sleep_for)
        set_soft_start()
        notify(
            "–ë–æ—Ç –≥–æ—Ç–æ–≤ –∫ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—é. "
            f"–í–∫–ª—é—á–µ–Ω –º—è–≥–∫–∏–π —Å—Ç–∞—Ä—Ç –Ω–∞ 3 –º–∏–Ω—É—Ç—ã (–ø–æ–Ω–∏–∂–µ–Ω–Ω—ã–π RPS). {reason_text}"
        )

    thread = threading.Thread(
        target=_cooldown_waiter,
        args=(COOLDOWN_UNTIL, reason),
        daemon=True,
    )
    thread.start()


def get_cooldown_remaining() -> int:
    with COOLDOWN_LOCK:
        remaining = int(COOLDOWN_UNTIL - time.time())
    return max(0, remaining)

# Optional notifier for external callbacks (e.g., Telegram bot)
NOTIFY_CALLBACK = None

# =========================
# ===== –û–ë–©–ò–ô –ö–û–ù–§–ò–ì ======
# =========================
CONFIG = {
    # --- –≠–¢–ê–ü 1: –ø–æ–∏—Å–∫ –ª—é–±–æ–≥–æ ID —Å –Ω—É–∂–Ω–æ–π –¥–∞—Ç–æ–π (–±—ã—Å—Ç—Ä—ã–π –ø—Ä—ã–∂–æ–∫) ---
    "start_id": 46211501,
    "start_date": "24.03.2017",
    "target_date": "08.02.2017",
    "jump_multiplier": 20000,
    "max_attempts": 300,
    "pause_seconds": 1,
    "correction_steps": {
        50: 700000,
        30: 500000,
        7: 25000,
        0: 10000,
    },
    # --- –≠–¢–ê–ü 2: –±–∏–Ω–∞—Ä–Ω—ã–π –ø–æ–∏—Å–∫ FIRST/LAST ---
    "max_requests": 350,
    "request_delay": 1,
    "request_timeout": 15,
    "users_per_day": 25000,
    "min_jump": 20000,
    "max_jump": 1_200_000,
    "max_neighbor_probes": 14,
    "final_scan_limit": 200,
    "print_details": True,
    "print_requests": False,
    # --- –≠–¢–ê–ü 3: —É–º–Ω—ã–π –ø–µ—Ä–µ–±–æ—Ä –∏ –ø–æ–∏—Å–∫ –ø–æ –∏–º–µ–Ω–∏ ---
    "target_name": "vondeliasa",
    "requests_per_second": 15,
    "jitter_ms": 120,
    "backoff_base_seconds": 0.5,
    "backoff_max_seconds": 8.0,
    "backoff_factor": 2.0,
    "max_workers": 6,
    "batch_size": 50,
    "timeout": 10,
    "proxy_url": None,
    "log_file": "search_complete.log",
    "log_level": logging.INFO,
    "save_progress": True,
    "progress_file": "search_progress.json",
}

BASE_URL = "https://www.kleinanzeigen.de/s-bestandsliste.html?userId="

USER_AGENTS = [
    "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/122.0.0.0 Safari/537.36",
    "Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:123.0) Gecko/20100101 Firefox/123.0",
]


# =========================
# ===== –≠–¢–ê–ü 1 (1.py) =====
# =========================
def date_to_days(date_str: str) -> Optional[int]:
    """–ö–æ–Ω–≤–µ—Ä—Ç–∏—Ä—É–µ—Ç DD.MM.YYYY –≤ –¥–Ω–∏ (–æ–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ—Ç —Ä–∞–∑–Ω—ã–µ —Ñ–æ—Ä–º–∞—Ç—ã)."""
    if not date_str:
        return None

    date_str = str(date_str).strip().replace("/", ".").replace("-", ".")
    formats = [
        "%d.%m.%Y",
        "%d.%m.%y",
        "%Y.%m.%d",
        "%d-%m-%Y",
    ]

    for fmt in formats:
        try:
            date_obj = datetime.strptime(date_str, fmt)
            return date_obj.toordinal()
        except ValueError:
            continue

    print(f"ERROR: –ù–µ –º–æ–≥—É —Ä–∞—Å–ø–∞—Ä—Å–∏—Ç—å –¥–∞—Ç—É '{date_str}'")
    return None


def get_date_from_page(user_id: int, session: requests.Session, pause_seconds: int) -> Optional[str]:
    """–ü–æ–ª—É—á–∞–µ—Ç –¥–∞—Ç—É —Ä–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏–∏ —Å–æ —Å—Ç—Ä–∞–Ω–∏—Ü—ã."""
    url = f"{BASE_URL}{user_id}"
    try:
        if stop_requested():
            return None
        time.sleep(pause_seconds)
        response = session.get(url, timeout=10)
        if response.status_code == 404:
            return None

        match = re.search(
            r"Aktiv seit\s*(\d{1,2}[./]\d{1,2}[./]\d{2,4})",
            response.text,
        )
        if match:
            date_str = match.group(1).replace("/", ".")
            try:
                datetime.strptime(date_str, "%d.%m.%Y")
                return date_str
            except ValueError:
                try:
                    datetime.strptime(date_str, "%d.%m.%y")
                    return date_str
                except ValueError:
                    return None
        return None
    except Exception:
        return None


def get_proxies() -> Optional[dict]:
    proxy_url = CONFIG.get("proxy_url")
    if not proxy_url:
        return None
    return {
        "http": proxy_url,
        "https": proxy_url,
    }


def configure_session(session: requests.Session) -> requests.Session:
    proxies = get_proxies()
    if proxies:
        session.proxies.update(proxies)
    return session


def check_proxy_connection() -> Tuple[bool, Optional[str]]:
    proxies = get_proxies()
    if not proxies:
        return False, None
    try:
        with requests.Session() as session:
            configure_session(session)
            response = session.get(f"{BASE_URL}1", timeout=10)
            if response.status_code not in {200, 404}:
                return False, None
            ip_response = session.get("https://api.ipify.org?format=json", timeout=10)
            if ip_response.status_code != 200:
                return True, None
            ip_data = ip_response.json()
            return True, ip_data.get("ip")
    except Exception:
        return False, None


def check_proxy_geo() -> Optional[dict]:
    proxies = get_proxies()
    if not proxies:
        return None
    try:
        with requests.Session() as session:
            configure_session(session)
            response = session.get("http://ip-api.com/json", timeout=10)
            if response.status_code != 200:
                return None
            data = response.json()
            if data.get("status") != "success":
                return None
            return {
                "ip": data.get("query"),
                "countryCode": data.get("countryCode"),
                "regionName": data.get("regionName"),
                "city": data.get("city"),
            }
    except Exception:
        return None


def get_stats_summary() -> Optional[str]:
    if LAST_SEARCH is None:
        return None
    return LAST_SEARCH.stats_summary()


def recheck_errors() -> Optional[int]:
    if LAST_SEARCH is None:
        return None
    return LAST_SEARCH.recheck_errors()


def calculate_step(days_diff: int, correction_steps: Dict[int, int]) -> int:
    """–û–ø—Ä–µ–¥–µ–ª—è–µ—Ç —à–∞–≥ –∫–æ—Ä—Ä–µ–∫—Ç–∏—Ä–æ–≤–∫–∏ –ø–æ —Ç–∞–±–ª–∏—Ü–µ."""
    abs_diff = abs(days_diff)
    for threshold in sorted(correction_steps.keys(), reverse=True):
        if abs_diff > threshold:
            return correction_steps[threshold]
    return 500


def find_any_id_for_date() -> Optional[int]:
    """–ü–æ–∏—Å–∫ –ª—é–±–æ–≥–æ ID —Å –Ω—É–∂–Ω–æ–π –¥–∞—Ç–æ–π (–ª–æ–≥–∏–∫–∞ 1.py)."""
    session = configure_session(requests.Session())
    session.headers = {
        "User-Agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36"
    }

    start_id = CONFIG["start_id"]
    start_date = CONFIG["start_date"]
    target_date = CONFIG["target_date"]

    print("=== –≠–¢–ê–ü 1: –ü–û–ò–°–ö –ü–û–õ–¨–ó–û–í–ê–¢–ï–õ–Ø ===")
    print(f"–ò—â–µ–º –¥–∞—Ç—É: {target_date}")
    print(f"–°—Ç–∞—Ä—Ç: ID {start_id} –æ—Ç {start_date}")
    print(
        f"–ù–∞—Å—Ç—Ä–æ–π–∫–∏: –º–Ω–æ–∂–∏—Ç–µ–ª—å={CONFIG['jump_multiplier']}, –ø–∞—É–∑–∞={CONFIG['pause_seconds']}—Å"
    )
    print(f"–ö–æ—Ä—Ä–µ–∫—Ç–∏—Ä–æ–≤–∫–∏: {CONFIG['correction_steps']}")
    print("=" * 40)

    print(f"[1] ID {start_id} -> ", end="")
    start_date_found = get_date_from_page(
        start_id, session, CONFIG["pause_seconds"]
    )
    if not start_date_found:
        print("–û–®–ò–ë–ö–ê: –ù–µ –≤–∏–¥–∏–º –¥–∞—Ç—É —Å—Ç–∞—Ä—Ç–æ–≤–æ–≥–æ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è!")
        return None
    print(f"{start_date_found}")

    if start_date_found != start_date:
        print(f"–í–ù–ò–ú–ê–ù–ò–ï: –£–∫–∞–∑–∞–ª–∏ {start_date}, –∞ –Ω–∞ —Å–∞–π—Ç–µ {start_date_found}")
        print("–ü—Ä–æ–¥–æ–ª–∂–∞–µ–º –ø–æ–∏—Å–∫ —Å –¥–∞—Ç–æ–π —Å —Å–∞–π—Ç–∞...")
        actual_start_date = start_date_found
    else:
        actual_start_date = start_date

    start_days = date_to_days(actual_start_date)
    target_days = date_to_days(target_date)

    if not start_days or not target_days:
        print(f"–û—à–∏–±–∫–∞ —Ñ–æ—Ä–º–∞—Ç–∞ –¥–∞—Ç—ã! start_days={start_days}, target_days={target_days}")
        return None

    days_diff = start_days - target_days
    initial_jump = days_diff * CONFIG["jump_multiplier"]
    current_id = start_id - initial_jump

    print(f"–†–∞–∑–Ω–∏—Ü–∞: {days_diff} –¥–Ω–µ–π")
    print(f"–ü—Ä—ã–∂–æ–∫: {initial_jump} ID -> –ø—Ä–æ–≤–µ—Ä—è–µ–º ID {current_id}")
    print("-" * 40)

    for attempt in range(2, CONFIG["max_attempts"] + 1):
        if stop_requested():
            print("‚èπÔ∏è –ü–æ–∏—Å–∫ –æ—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–º.")
            return None
        if current_id <= 0:
            print("ID —Å—Ç–∞–ª –æ—Ç—Ä–∏—Ü–∞—Ç–µ–ª—å–Ω—ã–º!")
            current_id = 1
            continue

        print(f"[{attempt}] ID {current_id} -> ", end="", flush=True)
        date_found = get_date_from_page(current_id, session, CONFIG["pause_seconds"])

        if date_found is None:
            print("–ù–µ—Ç –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è")
            current_id += 1 if days_diff > 0 else -1
            continue

        print(f"{date_found}")
        current_days = date_to_days(date_found)
        if not current_days:
            current_id += 100
            continue

        if current_days == target_days:
            print("\n" + "=" * 40)
            print(f"–ù–ê–ô–î–ï–ù–û! ID: {current_id}")
            print(f"–î–∞—Ç–∞: {date_found}")
            print(f"–°—Å—ã–ª–∫–∞: {BASE_URL}{current_id}")
            print("=" * 40)
            return current_id

        if current_days > target_days:
            direction = -1
            diff = current_days - target_days
        else:
            direction = 1
            diff = target_days - current_days

        step = calculate_step(diff, CONFIG["correction_steps"]) * direction
        print(f"    –ö–æ—Ä—Ä–µ–∫—Ç–∏—Ä–æ–≤–∫–∞: {step} ID (—Ä–∞–∑–Ω–∏—Ü–∞ {diff} –¥–Ω–µ–π)")
        current_id += step

    print(f"\n–ù–µ –Ω–∞–π–¥–µ–Ω–æ –∑–∞ {CONFIG['max_attempts']} –ø–æ–ø—ã—Ç–æ–∫")
    print(f"–ü–æ—Å–ª–µ–¥–Ω–∏–π ID: {current_id}")
    return None


# =========================
# ===== –≠–¢–ê–ü 2 (2v2.py) ===
# =========================
AKTIV_RE = re.compile(
    r"Aktiv\s*seit\s*(\d{1,2}[./]\d{1,2}[./]\d{2,4})",
    re.IGNORECASE,
)


def norm_date(s: str) -> Optional[str]:
    s = s.replace("/", ".")
    for fmt in ("%d.%m.%Y", "%d.%m.%y"):
        try:
            return datetime.strptime(s, fmt).strftime("%d.%m.%Y")
        except ValueError:
            pass
    return None


def ord_date(s: str) -> int:
    return datetime.strptime(s, "%d.%m.%Y").toordinal()


class Finder:
    def __init__(self):
        self.session = configure_session(requests.Session())
        self.session.headers.update(
            {
                "User-Agent": random.choice(USER_AGENTS),
                "Accept-Language": "de-DE,de;q=0.9",
                "DNT": "1",
            }
        )
        self.req = 0
        self.cache: Dict[int, Optional[str]] = {}

    def log(self, msg: str):
        if CONFIG["print_details"]:
            print(f"[{time.strftime('%H:%M:%S')}] {msg}")

    def budget_ok(self) -> bool:
        return self.req < CONFIG["max_requests"]

    def fetch_date(self, uid: int) -> Optional[str]:
        if uid < 1 or not self.budget_ok() or stop_requested():
            return None
        if uid in self.cache:
            return self.cache[uid]

        time.sleep(CONFIG["request_delay"])
        try:
            r = self.session.get(f"{BASE_URL}{uid}", timeout=CONFIG["request_timeout"])
            self.req += 1
            if CONFIG["print_requests"]:
                self.log(f"REQ {self.req}/{CONFIG['max_requests']}: {uid} -> {r.status_code}")

            if r.status_code != 200:
                self.cache[uid] = None
                return None

            m = AKTIV_RE.search(r.text)
            if not m:
                self.cache[uid] = None
                return None

            d = norm_date(m.group(1))
            self.cache[uid] = d
            return d
        except Exception:
            self.req += 1
            return None

    def nearest_ok(self, uid: int, lo: int, hi: int) -> Tuple[Optional[int], Optional[str]]:
        d = self.fetch_date(uid)
        if d and lo <= uid <= hi:
            return uid, d

        step = 1
        for _ in range(CONFIG["max_neighbor_probes"]):
            for c in (uid - step, uid + step):
                if c < lo or c > hi:
                    continue
                dd = self.fetch_date(c)
                if dd:
                    return c, dd
            step *= 2
        return None, None

    def jump(self, uid: int, days: int, direction: int) -> int:
        step = max(
            CONFIG["min_jump"],
            min(days * CONFIG["users_per_day"], CONFIG["max_jump"]),
        )
        return uid + direction * step

    def find_first(self, known: int, target_date: str) -> Optional[int]:
        tord = ord_date(target_date)
        hi = known

        days = 1
        while self.budget_ok():
            cand = self.jump(hi, days, -1)
            cid, cd = self.nearest_ok(cand, 1, hi - 1)
            if cid and ord_date(cd) < tord:
                lo = cid
                break
            days *= 2
        else:
            return None

        left, right = lo, hi
        while left < right - 1 and self.budget_ok():
            mid = (left + right) // 2
            mid_id, mid_d = self.nearest_ok(mid, left + 1, right - 1)

            if not mid_id:
                right -= 1
                continue

            if ord_date(mid_d) < tord:
                left = mid_id
            else:
                right = mid_id

            self.log(f"FIRST step: {left} .. {right}")

        cur = right
        for _ in range(CONFIG["final_scan_limit"]):
            pid, pd = self.nearest_ok(cur - 1, 1, cur - 1)
            if not pid or ord_date(pd) < tord:
                return cur
            cur = pid

        return cur

    def find_last(self, first: int, target_date: str) -> Optional[int]:
        tord = ord_date(target_date)
        lo = first

        days = 1
        while self.budget_ok():
            cand = self.jump(lo, days, +1)
            cid, cd = self.nearest_ok(cand, lo + 1, cand + CONFIG["max_jump"])
            if cid and ord_date(cd) > tord:
                hi = cid
                break
            days *= 2
        else:
            return None

        left, right = lo, hi
        while left < right - 1 and self.budget_ok():
            mid = (left + right) // 2
            mid_id, mid_d = self.nearest_ok(mid, left + 1, right - 1)

            if not mid_id:
                left += 1
                continue

            if ord_date(mid_d) <= tord:
                left = mid_id
            else:
                right = mid_id

            self.log(f"LAST step: {left} .. {right}")

        cur = left
        for _ in range(CONFIG["final_scan_limit"]):
            nid, nd = self.nearest_ok(cur + 1, cur + 1, cur + 1 + CONFIG["max_jump"])
            if not nid or ord_date(nd) > tord:
                return cur
            cur = nid

        return cur


def find_day_boundaries(known_id: int) -> Optional[Tuple[int, int]]:
    print("=" * 70)
    print("üöÄ –≠–¢–ê–ü 2 ‚Äî –ø–æ–∏—Å–∫ –≥—Ä–∞–Ω–∏—Ü —Ä–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏–∏ (stable)")
    print("=" * 70)
    print(f"–î–∞—Ç–∞   : {CONFIG['target_date']}")
    print(f"Known ID: {known_id}")
    print("=" * 70)

    finder = Finder()
    first = finder.find_first(known_id, CONFIG["target_date"])
    if not first:
        print("‚ùå FIRST_ID –Ω–µ –Ω–∞–π–¥–µ–Ω")
        return None

    last = finder.find_last(first, CONFIG["target_date"])
    if not last:
        print("‚ùå LAST_ID –Ω–µ –Ω–∞–π–¥–µ–Ω")
        return None

    print("\n" + "=" * 70)
    print("‚úÖ –†–ï–ó–£–õ–¨–¢–ê–¢")
    print("=" * 70)
    print(f"KNOWN_ID : {known_id}")
    print(f"FIRST_ID : {first}")
    print(f"LAST_ID  : {last}")
    print(f"COUNT    : {last - first + 1:,}")
    print(f"REQUESTS : {finder.req}/{CONFIG['max_requests']}")
    print("=" * 70)
    return first, last


# =========================
# ===== –≠–¢–ê–ü 3 (3neu.py) ==
# =========================
HEADERS = {
    "Accept": "text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8",
    "Accept-Encoding": "gzip, deflate, br",
    "DNT": "1",
    "Connection": "keep-alive",
    "Upgrade-Insecure-Requests": "1",
}

ACCEPT_LANGUAGES = [
    "de-DE,de;q=0.9,en-US;q=0.8,en;q=0.7",
    "de-DE,de;q=0.9",
    "de-CH,de;q=0.9,en-US;q=0.7,en;q=0.5",
]

USER_AGENT_POOL = [
    "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/122.0.0.0 Safari/537.36",
    "Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:123.0) Gecko/20100101 Firefox/123.0",
    "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/121.0.0.0 Safari/537.36",
]


def build_headers() -> dict:
    headers = HEADERS.copy()
    headers["User-Agent"] = random.choice(USER_AGENT_POOL)
    headers["Accept-Language"] = random.choice(ACCEPT_LANGUAGES)
    return headers


class RateLimiter:
    """–ö–æ–Ω—Ç—Ä–æ–ª–µ—Ä —Å–∫–æ—Ä–æ—Å—Ç–∏ –∑–∞–ø—Ä–æ—Å–æ–≤."""

    def __init__(self, requests_per_second: int):
        self.requests_per_second = requests_per_second
        self.min_interval = 1.0 / requests_per_second
        self.last_request_time = 0
        self.lock = threading.Lock()

    def wait(self):
        """–ñ–¥–µ—Ç –Ω–µ–æ–±—Ö–æ–¥–∏–º–æ–µ –≤—Ä–µ–º—è –ø–µ—Ä–µ–¥ —Å–ª–µ–¥—É—é—â–∏–º –∑–∞–ø—Ä–æ—Å–æ–º."""
        with self.lock:
            effective_rps = get_effective_rps(self.requests_per_second)
            if effective_rps <= 0:
                return
            min_interval = 1.0 / effective_rps
            current_time = time.time()
            elapsed = current_time - self.last_request_time

            if elapsed < min_interval:
                sleep_time = min_interval - elapsed
                jitter_ms = CONFIG.get("jitter_ms", 0) or 0
                jitter = random.uniform(0, jitter_ms / 1000) if jitter_ms > 0 else 0
                time.sleep(sleep_time + jitter)

            self.last_request_time = time.time()


class SearchLogger:
    """–ö–∞—Å—Ç–æ–º–Ω—ã–π –ª–æ–≥–≥–µ—Ä —Å –∫—Ä–∞—Å–∏–≤—ã–º –≤—ã–≤–æ–¥–æ–º."""

    def __init__(self):
        self.logger = logging.getLogger("KleinanzeigenSearch")
        if self.logger.handlers:
            self.logger.handlers.clear()

        file_handler = logging.FileHandler(CONFIG["log_file"], encoding="utf-8")
        file_handler.setFormatter(
            logging.Formatter("%(asctime)s - %(levelname)s - %(message)s")
        )

        console_handler = logging.StreamHandler()
        console_handler.setFormatter(logging.Formatter("%(message)s"))

        self.logger.setLevel(CONFIG["log_level"])
        self.logger.addHandler(file_handler)
        self.logger.addHandler(console_handler)

        self.colors = {
            "INFO": "\033[94m",
            "SUCCESS": "\033[92m",
            "WARNING": "\033[93m",
            "ERROR": "\033[91m",
            "DEBUG": "\033[90m",
            "FOUND": "\033[95m",
            "FOUND_BANNER": "\033[1;35m",
            "RESET": "\033[0m",
        }

    def log(self, level: str, message: str, user_id: int = None, details: dict = None):
        """–õ–æ–≥–∏—Ä–æ–≤–∞–Ω–∏–µ —Å –∫—Ä–∞—Å–∏–≤—ã–º —Ñ–æ—Ä–º–∞—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ–º."""
        timestamp = datetime.now().strftime("%H:%M:%S")

        if user_id:
            base_msg = f"[{timestamp}] [{level}] ID {user_id}: {message}"
        else:
            base_msg = f"[{timestamp}] [{level}]: {message}"

        if details:
            details_str = " | ".join(
                [f"{k}={v}" for k, v in details.items() if v is not None]
            )
            if details_str:
                base_msg += f" | {details_str}"

        if level == "FOUND":
            self.logger.warning(base_msg)
        elif level == "SUCCESS":
            self.logger.info(base_msg)
        else:
            getattr(self.logger, level.lower())(base_msg)

        color = self.colors.get(level, self.colors["RESET"])
        console_msg = f"{color}{base_msg}{self.colors['RESET']}"

        if level in ["PROGRESS", "FOUND", "ERROR"]:
            print(console_msg)
        else:
            if level in ["WARNING", "SUCCESS"] or "ERROR" in level:
                print(console_msg)


def set_notify_callback(callback):
    global NOTIFY_CALLBACK
    NOTIFY_CALLBACK = callback


def notify(message: str) -> None:
    if NOTIFY_CALLBACK:
        try:
            NOTIFY_CALLBACK(message)
        except Exception:
            pass


@dataclass
class SearchConfig:
    start_id: int
    end_id: int
    target_name: str
    target_date: str


class ReliableUserSearch:
    def __init__(self, search_config: SearchConfig):
        global LAST_SEARCH
        self.start_id = search_config.start_id
        self.end_id = search_config.end_id
        self.target_name = search_config.target_name
        self.target_date = search_config.target_date
        self.total_users = self.end_id - self.start_id + 1

        self.logger = SearchLogger()
        self.rate_limiter = RateLimiter(CONFIG["requests_per_second"])

        self.found_users = []
        self.checked_ids = set()
        self.error_ids = set()
        self.request_count = 0
        self.success_count = 0
        self.error_count = 0
        self.parse_fail_count = 0
        self.missing_ids = set()
        self.start_time = time.time()

        self.lock = threading.Lock()
        self.session = configure_session(requests.Session())
        self.session.headers.update(build_headers())

        self.error_stats = defaultdict(int)
        self.error_codes = defaultdict(int)
        self.consecutive_403 = 0

        self.should_stop = False
        if threading.current_thread() is threading.main_thread():
            signal.signal(signal.SIGINT, self.signal_handler)

        if CONFIG["save_progress"]:
            self.load_progress()

        LAST_SEARCH = self

        self.show_header()
        self.print_expected_stats()

    def signal_handler(self, signum, frame):
        """–û–±—Ä–∞–±–æ—Ç—á–∏–∫ Ctrl+C."""
        self.logger.log("WARNING", "–ü–æ–ª—É—á–µ–Ω —Å–∏–≥–Ω–∞–ª –æ—Å—Ç–∞–Ω–æ–≤–∫–∏, –∑–∞–≤–µ—Ä—à–∞–µ–º...")
        self.should_stop = True

    def show_header(self):
        """–ö—Ä–∞—Å–∏–≤—ã–π –∑–∞–≥–æ–ª–æ–≤–æ–∫."""
        print("\n" + "=" * 80)
        print("üîç KLEINANZEIGEN –ü–û–ò–°–ö –ü–û–õ–¨–ó–û–í–ê–¢–ï–õ–Ø - –ù–ê–î–ï–ñ–ù–ê–Ø –í–ï–†–°–ò–Ø")
        print("=" * 80)
        print(f"üéØ –¶–µ–ª—å: '{self.target_name}'")
        print(f"üìä –î–∏–∞–ø–∞–∑–æ–Ω: {self.start_id:,} - {self.end_id:,}")
        print(f"üìà –í—Å–µ–≥–æ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π: {self.total_users:,}")
        print(f"‚ö° –°–∫–æ—Ä–æ—Å—Ç—å: {CONFIG['requests_per_second']} –∑–∞–ø—Ä–æ—Å–æ–≤/—Å–µ–∫")
        print(f"üßµ –ü–æ—Ç–æ–∫–æ–≤: {CONFIG['max_workers']}")
        print("=" * 80)
        print(f"üìù –ü–æ–ª–Ω—ã–π –ª–æ–≥: {CONFIG['log_file']}")
        print(f"üíæ –ê–≤—Ç–æ—Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏–µ: {CONFIG['progress_file']}")
        print("=" * 80 + "\n")

    def print_expected_stats(self):
        """–†–∞—Å—á–µ—Ç –æ–∂–∏–¥–∞–µ–º–æ–π –ø—Ä–æ–∏–∑–≤–æ–¥–∏—Ç–µ–ª—å–Ω–æ—Å—Ç–∏."""
        total_requests = self.total_users
        estimated_time = total_requests / CONFIG["requests_per_second"]

        self.logger.log("INFO", "–†–ê–°–ß–ï–¢ –ü–†–û–ò–ó–í–û–î–ò–¢–ï–õ–¨–ù–û–°–¢–ò:")
        self.logger.log("INFO", f"  ‚Ä¢ –í—Å–µ–≥–æ –∑–∞–ø—Ä–æ—Å–æ–≤: {total_requests:,}")
        self.logger.log(
            "INFO", f"  ‚Ä¢ –¶–µ–ª–µ–≤–∞—è —Å–∫–æ—Ä–æ—Å—Ç—å: {CONFIG['requests_per_second']} –∑–∞–ø—Ä/—Å–µ–∫"
        )

        if estimated_time < 60:
            self.logger.log("SUCCESS", f"  ‚Ä¢ –†–∞—Å—á–µ—Ç–Ω–æ–µ –≤—Ä–µ–º—è: {estimated_time:.1f} —Å–µ–∫—É–Ω–¥")
        elif estimated_time < 3600:
            minutes = estimated_time / 60
            self.logger.log("SUCCESS", f"  ‚Ä¢ –†–∞—Å—á–µ—Ç–Ω–æ–µ –≤—Ä–µ–º—è: {minutes:.1f} –º–∏–Ω—É—Ç")
        else:
            hours = estimated_time / 3600
            self.logger.log("SUCCESS", f"  ‚Ä¢ –†–∞—Å—á–µ—Ç–Ω–æ–µ –≤—Ä–µ–º—è: {hours:.1f} —á–∞—Å–æ–≤")

        print()

    def clean_name(self, name: str) -> str:
        """–û—á–∏—Å—Ç–∫–∞ –∏–º–µ–Ω–∏ –æ—Ç –ª–∏—à–Ω–∏—Ö –ø—Ä–æ–±–µ–ª–æ–≤."""
        if not name:
            return ""
        return re.sub(r"\s+", " ", name.strip())

    def extract_name_from_html(self, html: str):
        """–ò–∑–≤–ª–µ—á–µ–Ω–∏–µ –∏–º–µ–Ω–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è –∏–∑ HTML."""
        try:
            pattern = (
                r'<h2\s+class="userprofile--name">\s*<span\s+class="sr-only">'
                r"Profil\s+von</span>\s*(.*?)\s*</h2>"
            )
            match = re.search(pattern, html, re.DOTALL | re.IGNORECASE)

            if match:
                name = match.group(1).strip()
                name = re.sub(r"&[a-z]+;", " ", name)
                return self.clean_name(name)

            pattern2 = r'"userprofile--name"[^>]*>.*?Profil von.*?>\s*(.*?)\s*<'
            match = re.search(pattern2, html, re.DOTALL | re.IGNORECASE)
            if match:
                name = match.group(1).strip()
                return self.clean_name(name)

            return None
        except Exception as e:
            self.logger.log("DEBUG", f"–û—à–∏–±–∫–∞ –ø–∞—Ä—Å–∏–Ω–≥–∞ –∏–º–µ–Ω–∏: {str(e)[:50]}")
            return None

    def is_exact_match(self, found_name: str) -> bool:
        """–ü—Ä–æ–≤–µ—Ä–∫–∞ —Ç–æ—á–Ω–æ–≥–æ —Å–æ–≤–ø–∞–¥–µ–Ω–∏—è –∏–º–µ–Ω–∏."""
        if not found_name:
            return False
        clean_found = self.clean_name(found_name).lower()
        clean_target = self.clean_name(self.target_name).lower()
        return clean_found == clean_target

    def fetch_user_page(self, user_id: int):
        """–ü–æ–ª—É—á–µ–Ω–∏–µ —Å—Ç—Ä–∞–Ω–∏—Ü—ã –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è —Å –∫–æ–Ω—Ç—Ä–æ–ª–µ–º —Å–∫–æ—Ä–æ—Å—Ç–∏."""
        self.rate_limiter.wait()
        url = f"{BASE_URL}{user_id}"

        try:
            self.session.headers.update(build_headers())
            response = self.session.get(url, timeout=CONFIG["timeout"])

            with self.lock:
                self.request_count += 1
                self.success_count += 1
                if response.status_code == 403:
                    self.consecutive_403 += 1
                else:
                    self.consecutive_403 = 0
                if response.status_code != 200:
                    self.error_ids.add(user_id)

            if response.status_code == 403:
                backoff = CONFIG.get("backoff_base_seconds", 0.5)
                factor = CONFIG.get("backoff_factor", 2.0)
                max_backoff = CONFIG.get("backoff_max_seconds", 8.0)
                sleep_time = min(backoff * (factor ** (self.consecutive_403 - 1)), max_backoff)
                time.sleep(sleep_time)

            return {
                "success": True,
                "status_code": response.status_code,
                "html": response.text if response.status_code == 200 else None,
                "error": None,
            }
        except requests.exceptions.Timeout:
            with self.lock:
                self.request_count += 1
                self.error_count += 1
                self.error_stats["timeout"] += 1
                self.error_ids.add(user_id)

            return {
                "success": False,
                "status_code": None,
                "html": None,
                "error": "timeout",
            }
        except requests.exceptions.ConnectionError:
            with self.lock:
                self.request_count += 1
                self.error_count += 1
                self.error_stats["connection"] += 1
                self.error_ids.add(user_id)

            return {
                "success": False,
                "status_code": None,
                "html": None,
                "error": "connection",
            }
        except Exception as e:
            with self.lock:
                self.request_count += 1
                self.error_count += 1
                self.error_stats["other"] += 1
                self.error_ids.add(user_id)

            return {
                "success": False,
                "status_code": None,
                "html": None,
                "error": f"other: {str(e)[:50]}",
            }

    def process_user(self, user_id: int):
        """–û–±—Ä–∞–±–æ—Ç–∫–∞ –æ–¥–Ω–æ–≥–æ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è."""
        if self.should_stop:
            return None

        result = self.fetch_user_page(user_id)

        if result["success"]:
            if result["status_code"] == 200:
                name = self.extract_name_from_html(result["html"])

                if name:
                    if self.is_exact_match(name):
                        user_data = {
                            "id": user_id,
                            "name": name,
                            "url": f"{BASE_URL}{user_id}",
                            "timestamp": datetime.now().isoformat(),
                        }

                        with self.lock:
                            self.found_users.append(user_data)

                        print("\n" + "‚≠ê" * 70)
                        print("‚≠ê" * 25 + " –ù–ê–ô–î–ï–ù –¶–ï–õ–ï–í–û–ô –ü–û–õ–¨–ó–û–í–ê–¢–ï–õ–¨! " + "‚≠ê" * 25)
                        print("‚≠ê" * 70)
                        print(f"‚≠ê ID: {user_id}")
                        print(f"‚≠ê –ò–ú–Ø: {name}")
                        print(f"‚≠ê –°–°–´–õ–ö–ê: {BASE_URL}{user_id}")
                        print(f"‚≠ê –í–†–ï–ú–Ø: {datetime.now().strftime('%H:%M:%S')}")
                        print("‚≠ê" * 70)
                        print("‚≠ê –°–∫—Ä–∏–ø—Ç –ø—Ä–æ–¥–æ–ª–∂–∏—Ç —Ä–∞–±–æ—Ç—É –¥–ª—è –ø–æ–∏—Å–∫–∞ –¥—Ä—É–≥–∏—Ö —Å–æ–≤–ø–∞–¥–µ–Ω–∏–π")
                        print("‚≠ê" * 70 + "\n")

                        self.logger.log(
                            "FOUND",
                            "–ù–ê–ô–î–ï–ù –ü–û–õ–¨–ó–û–í–ê–¢–ï–õ–¨!",
                            user_id,
                            {"name": name, "status": "FOUND"},
                        )
                        notify(f"–ù–∞–π–¥–µ–Ω –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å: {name}\n{BASE_URL}{user_id}")
                        return user_data

                    self.logger.log("INFO", "–ü—Ä–æ–≤–µ—Ä–µ–Ω", user_id, {"name": name})
                else:
                    with self.lock:
                        self.parse_fail_count += 1
                    self.logger.log("DEBUG", "–ò–º—è –Ω–µ –Ω–∞–π–¥–µ–Ω–æ –≤ HTML", user_id)
            else:
                with self.lock:
                    self.error_codes[result["status_code"]] += 1

                self.logger.log(
                    "ERROR",
                    "HTTP –æ—à–∏–±–∫–∞",
                    user_id,
                    {"status": result["status_code"]},
                )
                self._check_error_threshold()
        else:
            self.logger.log("ERROR", "–û—à–∏–±–∫–∞ –∑–∞–ø—Ä–æ—Å–∞", user_id, {"error": result["error"]})
            self._check_error_threshold()

        return None

    def print_progress(self):
        """–ö—Ä–∞—Å–∏–≤—ã–π –≤—ã–≤–æ–¥ –ø—Ä–æ–≥—Ä–µ—Å—Å–∞."""
        with self.lock:
            checked = len(self.checked_ids)
            requests_count = self.request_count
            errors = self._total_error_count()
            found = len(self.found_users)

        elapsed = time.time() - self.start_time
        progress_pct = (checked / self.total_users * 100) if self.total_users > 0 else 0

        speed = requests_count / elapsed if elapsed > 0 else 0

        if speed > 0 and checked < self.total_users:
            remaining = self.total_users - checked
            eta_seconds = remaining / speed

            if eta_seconds < 60:
                eta_str = f"{eta_seconds:.0f}—Å"
            elif eta_seconds < 3600:
                eta_str = f"{eta_seconds/60:.0f}–º"
            else:
                eta_str = f"{eta_seconds/3600:.1f}—á"
        else:
            eta_str = "---"

        progress_line = (
            f"[{datetime.now().strftime('%H:%M:%S')}] "
            f"[PROGRESS] –ü—Ä–æ–≤–µ—Ä–µ–Ω–æ: {checked:,}/{self.total_users:,} ({progress_pct:.1f}%) | "
            f"–°–∫–æ—Ä–æ—Å—Ç—å: {speed:.1f} –∑–∞–ø—Ä/—Å–µ–∫ | "
            f"–û—Å—Ç–∞–ª–æ—Å—å: {eta_str} | "
            f"–ù–∞–π–¥–µ–Ω–æ: {found} | "
            f"–û—à–∏–±–æ–∫: {errors:,}"
        )

        if progress_pct < 30:
            color = "\033[91m"
        elif progress_pct < 70:
            color = "\033[93m"
        else:
            color = "\033[92m"

        print(f"{color}{progress_line}\033[0m", end="\r")

    def search_batch(self, batch_ids):
        """–ü–æ–∏—Å–∫ –≤ –ø–∞–∫–µ—Ç–µ ID."""
        with ThreadPoolExecutor(max_workers=CONFIG["max_workers"]) as executor:
            future_to_id = {
                executor.submit(self.process_user, user_id): user_id for user_id in batch_ids
            }

            for future in as_completed(future_to_id):
                user_id = future_to_id[future]

                try:
                    future.result(timeout=CONFIG["timeout"] + 5)
                except Exception as e:
                    self.logger.log(
                        "ERROR", "–û—à–∏–±–∫–∞ –æ–±—Ä–∞–±–æ—Ç–∫–∏", user_id, {"error": str(e)[:50]}
                    )

                with self.lock:
                    self.checked_ids.add(user_id)

                if len(self.checked_ids) % 5 == 0:
                    self.print_progress()

    def run_search(self):
        """–û—Å–Ω–æ–≤–Ω–æ–π –º–µ—Ç–æ–¥ –ø–æ–∏—Å–∫–∞."""
        self.logger.log("INFO", "üöÄ –ó–ê–ü–£–°–ö –ü–û–ò–°–ö–ê...")
        self.logger.log("INFO", "–ù–∞–∂–º–∏—Ç–µ Ctrl+C –¥–ª—è –±–µ–∑–æ–ø–∞—Å–Ω–æ–π –æ—Å—Ç–∞–Ω–æ–≤–∫–∏")
        print()

        self.print_progress()

        all_ids = range(self.start_id, self.end_id + 1)
        total_batches = (self.total_users + CONFIG["batch_size"] - 1) // CONFIG["batch_size"]

        for batch_num in range(total_batches):
            if self.should_stop or stop_requested():
                self.logger.log("WARNING", "–ü–æ–∏—Å–∫ –æ—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–º")
                break

            start_idx = batch_num * CONFIG["batch_size"]
            end_idx = min((batch_num + 1) * CONFIG["batch_size"], self.total_users)
            batch_ids = list(all_ids[start_idx:end_idx])

            batch_start = time.time()
            self.search_batch(batch_ids)
            batch_time = time.time() - batch_start

            if batch_time > 0 and len(batch_ids) > 0:
                batch_speed = len(batch_ids) / batch_time
                self.logger.log(
                    "DEBUG",
                    f"–ü–∞–∫–µ—Ç {batch_num+1}/{total_batches} –∑–∞–≤–µ—Ä—à–µ–Ω",
                    None,
                    {"–≤—Ä–µ–º—è": f"{batch_time:.1f}—Å", "—Å–∫–æ—Ä–æ—Å—Ç—å": f"{batch_speed:.1f} –∑–∞–ø—Ä/—Å–µ–∫"},
                )

            if CONFIG["save_progress"] and batch_num % 5 == 0:
                self.save_progress()

            if (
                batch_num < total_batches - 1
                and not self.should_stop
                and not stop_requested()
            ):
                time.sleep(0.3)

        self.print_progress()
        print("\n")

        self.check_missing_ids()
        return self.found_users

    def check_missing_ids(self):
        """–ü—Ä–æ–≤–µ—Ä–∫–∞ –ø—Ä–æ–ø—É—â–µ–Ω–Ω—ã—Ö ID."""
        expected_ids = set(range(self.start_id, self.end_id + 1))
        missing_ids = expected_ids - self.checked_ids

        if missing_ids:
            self.missing_ids = missing_ids
            self.logger.log("WARNING", f"–û–±–Ω–∞—Ä—É–∂–µ–Ω—ã –ø—Ä–æ–ø—É—â–µ–Ω–Ω—ã–µ ID: {len(missing_ids)}")

            first_missing = sorted(missing_ids)[:10]
            for mid in first_missing:
                self.logger.log("DEBUG", "–ü—Ä–æ–ø—É—â–µ–Ω ID", mid)

            if len(missing_ids) > 10:
                self.logger.log("DEBUG", f"... –∏ –µ—â–µ {len(missing_ids) - 10} ID")

    def stats_summary(self) -> str:
        with self.lock:
            checked = len(self.checked_ids)
            found = len(self.found_users)
            errors = self._total_error_count()
            http_errors = self._http_error_count()
            network_errors = self.error_count
            parse_errors = self.parse_fail_count
            requests_count = self.request_count
            total = self.total_users
        progress = (checked / total * 100) if total else 0
        return (
            f"–ü—Ä–æ–≥—Ä–µ—Å—Å: {progress:.1f}% ({checked:,}/{total:,})\n"
            f"–ù–∞–π–¥–µ–Ω–æ: {found}\n"
            f"–û—à–∏–±–æ–∫: {errors:,}\n"
            f"HTTP –æ—à–∏–±–∫–∏: {http_errors:,}\n"
            f"–°–µ—Ç–µ–≤—ã–µ –æ—à–∏–±–∫–∏: {network_errors:,}\n"
            f"–ü–∞—Ä—Å –∏–º–µ–Ω–∏: {parse_errors:,}\n"
            f"–ó–∞–ø—Ä–æ—Å–æ–≤: {requests_count:,}"
        )

    def _check_error_threshold(self) -> None:
        global ERROR_NOTIFY_SENT
        if ERROR_NOTIFY_SENT:
            return
        if self._total_error_count() < ERROR_STOP_THRESHOLD:
            return
        ERROR_NOTIFY_SENT = True
        summary = self._error_codes_summary()
        notify(
            "–ß—Ç–æ-—Ç–æ –ø–æ—à–ª–æ –Ω–µ —Ç–∞–∫: —Å–ª–∏—à–∫–æ–º –º–Ω–æ–≥–æ –æ—à–∏–±–æ–∫.\n"
            f"{summary}\n–ü–æ–∏—Å–∫ –æ—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω. –ü—Ä–æ–≤–µ—Ä—å—Ç–µ –∫–æ–¥/–ø—Ä–æ–∫—Å–∏."
        )
        self.should_stop = True
        cooldown_seconds, reason = self._cooldown_plan()
        set_cooldown(cooldown_seconds, reason)

    def _error_codes_summary(self) -> str:
        with self.lock:
            if not self.error_codes:
                return "–û—à–∏–±–æ–∫ –Ω–µ—Ç."
            parts = []
            for code, count in sorted(self.error_codes.items()):
                parts.append(f"{code}: {count}")
        return "–û—à–∏–±–∫–∏: " + ", ".join(parts)

    def _total_error_count(self) -> int:
        with self.lock:
            http_errors = sum(self.error_codes.values())
            return self.error_count + http_errors + self.parse_fail_count

    def _http_error_count(self) -> int:
        with self.lock:
            return sum(self.error_codes.values())

    def _error_detail_summary(self) -> str:
        with self.lock:
            http_errors = sum(self.error_codes.values())
            network_errors = self.error_count
            parse_errors = self.parse_fail_count
        return (
            f"{self._error_codes_summary()}\n"
            f"HTTP –æ—à–∏–±–∫–∏: {http_errors:,}\n"
            f"–°–µ—Ç–µ–≤—ã–µ –æ—à–∏–±–∫–∏: {network_errors:,}\n"
            f"–ü–∞—Ä—Å –∏–º–µ–Ω–∏: {parse_errors:,}"
        )

    def _cooldown_plan(self) -> Tuple[int, str]:
        with self.lock:
            err_403 = self.error_codes.get(403, 0)
            err_503 = self.error_codes.get(503, 0)
            err_504 = self.error_codes.get(504, 0)
            total_errors = (
                self.error_count + sum(self.error_codes.values()) + self.parse_fail_count
            )

        surge = err_403 + err_503
        if surge >= 1000 or total_errors >= 1000:
            cooldown = 15 * 60
            reason = "–û–±–Ω–∞—Ä—É–∂–µ–Ω–∞ –≤–æ–ª–Ω–∞ –æ—à–∏–±–æ–∫ 403/503."
        elif surge >= 500 or total_errors >= 500:
            cooldown = 10 * 60
            reason = "–í—Å–ø–ª–µ—Å–∫ –æ—à–∏–±–æ–∫ 403/503."
        elif surge >= 200 or total_errors >= 200:
            cooldown = 7 * 60
            reason = "–ü–æ–≤—ã—à–µ–Ω–Ω–æ–µ —á–∏—Å–ª–æ –æ—à–∏–±–æ–∫."
        else:
            cooldown = 5 * 60
            reason = "–ë–∞–∑–æ–≤—ã–π –æ—Ç–¥—ã—Ö –ø–æ—Å–ª–µ –ø—Ä–æ–≤–µ—Ä–∫–∏."

        if err_403 or err_503 or err_504:
            reason += f" 403={err_403}, 503={err_503}, 504={err_504}."
        return cooldown, reason

    def recheck_errors(self) -> int:
        with self.lock:
            error_ids = sorted(self.error_ids)
            self.error_ids.clear()

        if not error_ids:
            return 0

        self.logger.log("INFO", f"–ü–æ–≤—Ç–æ—Ä–Ω–∞—è –ø—Ä–æ–≤–µ—Ä–∫–∞ –æ—à–∏–±–æ–∫: {len(error_ids)} ID")
        self._recheck_ids(error_ids)
        return len(error_ids)

    def _recheck_ids(self, ids: list[int]) -> None:
        with ThreadPoolExecutor(max_workers=CONFIG["max_workers"]) as executor:
            future_to_id = {executor.submit(self.process_user, user_id): user_id for user_id in ids}

            for future in as_completed(future_to_id):
                user_id = future_to_id[future]
                try:
                    future.result(timeout=CONFIG["timeout"] + 5)
                except Exception as e:
                    self.logger.log(
                        "ERROR", "–û—à–∏–±–∫–∞ –ø–æ–≤—Ç–æ—Ä–Ω–æ–π –ø—Ä–æ–≤–µ—Ä–∫–∏", user_id, {"error": str(e)[:50]}
                    )

                with self.lock:
                    self.checked_ids.add(user_id)

                if len(self.checked_ids) % 5 == 0:
                    self.print_progress()

    def save_progress(self):
        """–°–æ—Ö—Ä–∞–Ω–µ–Ω–∏–µ –ø—Ä–æ–≥—Ä–µ—Å—Å–∞."""
        if not CONFIG["save_progress"]:
            return

        with self.lock:
            data = {
                "search_config": {
                    "start_id": self.start_id,
                    "end_id": self.end_id,
                    "target_name": self.target_name,
                    "target_date": self.target_date,
                },
                "progress": {
                    "checked_ids": sorted(list(self.checked_ids)),
                    "last_check_time": datetime.now().isoformat(),
                    "total_checked": len(self.checked_ids),
                },
                "results": {
                    "found_users": self.found_users,
                    "total_found": len(self.found_users),
                },
                "statistics": {
                    "requests": self.request_count,
                    "success": self.success_count,
                    "errors": self.error_count,
                    "parse_failures": self.parse_fail_count,
                    "error_stats": dict(self.error_stats),
                    "error_codes": dict(self.error_codes),
                },
                "missing_ids": sorted(list(self.missing_ids)),
            }

        try:
            with open(CONFIG["progress_file"], "w", encoding="utf-8") as f:
                json.dump(data, f, ensure_ascii=False, indent=2)

            self.logger.log("SUCCESS", "–ü—Ä–æ–≥—Ä–µ—Å—Å —Å–æ—Ö—Ä–∞–Ω–µ–Ω")
        except Exception as e:
            self.logger.log("ERROR", "–û—à–∏–±–∫–∞ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏—è –ø—Ä–æ–≥—Ä–µ—Å—Å–∞", None, {"error": str(e)})

    def load_progress(self):
        """–ó–∞–≥—Ä—É–∑–∫–∞ –ø—Ä–æ–≥—Ä–µ—Å—Å–∞."""
        try:
            with open(CONFIG["progress_file"], "r", encoding="utf-8") as f:
                data = json.load(f)

            config = data.get("search_config", {})
            if (
                config.get("start_id") == self.start_id
                and config.get("end_id") == self.end_id
                and config.get("target_name") == self.target_name
            ):
                progress = data.get("progress", {})
                self.checked_ids = set(progress.get("checked_ids", []))

                results = data.get("results", {})
                self.found_users = results.get("found_users", [])

                stats = data.get("statistics", {})
                self.request_count = stats.get("requests", 0)
                self.success_count = stats.get("success", 0)
                self.error_count = stats.get("errors", 0)
                self.parse_fail_count = stats.get("parse_failures", 0)

                missing = data.get("missing_ids", [])
                self.missing_ids = set(missing)

                self.logger.log(
                    "SUCCESS",
                    f"–ó–∞–≥—Ä—É–∂–µ–Ω –ø—Ä–æ–≥—Ä–µ—Å—Å: {len(self.checked_ids):,} –ø—Ä–æ–≤–µ—Ä–µ–Ω–Ω—ã—Ö",
                )
                self.logger.log(
                    "SUCCESS", f"–£–∂–µ –Ω–∞–π–¥–µ–Ω–æ: {len(self.found_users)} –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π"
                )

                if self.missing_ids:
                    self.logger.log("WARNING", f"–ï—Å—Ç—å –ø—Ä–æ–ø—É—â–µ–Ω–Ω—ã–µ ID: {len(self.missing_ids)}")

        except FileNotFoundError:
            self.logger.log("INFO", "–ü—Ä–æ–≥—Ä–µ—Å—Å –Ω–µ –Ω–∞–π–¥–µ–Ω, –Ω–∞—á–∏–Ω–∞–µ–º —Å –Ω–∞—á–∞–ª–∞")
        except Exception as e:
            self.logger.log("ERROR", "–û—à–∏–±–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∏ –ø—Ä–æ–≥—Ä–µ—Å—Å–∞", None, {"error": str(e)})

    def print_final_report(self):
        """–ö—Ä–∞—Å–∏–≤—ã–π —Ñ–∏–Ω–∞–ª—å–Ω—ã–π –æ—Ç—á–µ—Ç —Å –≤—ã–¥–µ–ª–µ–Ω–∏–µ–º –Ω–∞–π–¥–µ–Ω–Ω—ã—Ö –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π."""
        print("\n" + "=" * 80)
        print("üìä –§–ò–ù–ê–õ–¨–ù–´–ô –û–¢–ß–ï–¢ –ü–û–ò–°–ö–ê")
        print("=" * 80)

        elapsed = time.time() - self.start_time

        with self.lock:
            checked = len(self.checked_ids)
            requests_count = self.request_count
            errors = self.error_count
            found = len(self.found_users)
            missing = len(self.missing_ids)

        if elapsed < 60:
            time_str = f"{elapsed:.1f} —Å–µ–∫—É–Ω–¥"
        elif elapsed < 3600:
            time_str = f"{elapsed/60:.1f} –º–∏–Ω—É—Ç"
        else:
            time_str = f"{elapsed/3600:.1f} —á–∞—Å–æ–≤"

        print(f"\n‚è±Ô∏è  –û–ë–©–ï–ï –í–†–ï–ú–Ø: {time_str}")
        print(f"üìä –ü–†–û–í–ï–†–ï–ù–û: {checked:,}/{self.total_users:,} –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π")

        if elapsed > 0:
            avg_speed = requests_count / elapsed
            print(f"‚ö° –°–†–ï–î–ù–Ø–Ø –°–ö–û–†–û–°–¢–¨: {avg_speed:.1f} –∑–∞–ø—Ä–æ—Å–æ–≤/—Å–µ–∫")

        print(f"‚úÖ –£–°–ü–ï–®–ù–´–• –ó–ê–ü–†–û–°–û–í: {self.success_count:,}")
        print(f"‚ùå –û–®–ò–ë–û–ö: {errors:,}")

        if self.error_stats:
            print("\nüîß –°–¢–ê–¢–ò–°–¢–ò–ö–ê –û–®–ò–ë–û–ö:")
            for error_type, count in sorted(self.error_stats.items()):
                if count > 0:
                    percentage = (count / errors * 100) if errors > 0 else 0
                    print(f"   ‚Ä¢ {error_type}: {count:,} ({percentage:.1f}%)")

        if self.error_codes:
            print("\nüì° HTTP –°–¢–ê–¢–£–°–´:")
            for code, count in sorted(self.error_codes.items()):
                print(f"   ‚Ä¢ {code}: {count:,}")

        if missing > 0:
            print(f"\n‚ö†Ô∏è  –ü–†–û–ü–£–©–ï–ù–û ID: {missing:,}")
            if missing <= 20:
                print(f"   ID: {sorted(self.missing_ids)}")

        print("\n" + "-" * 40)
        print("üéØ –†–ï–ó–£–õ–¨–¢–ê–¢–´ –ü–û–ò–°–ö–ê:")

        if found > 0:
            print("\n" + "üéØ" * 40)
            print(f"üéØ –ù–ê–ô–î–ï–ù–û –¶–ï–õ–ï–í–´–• –ü–û–õ–¨–ó–û–í–ê–¢–ï–õ–ï–ô: {found}")
            print("üéØ" * 40)

            notify(
                "–ù–∞–π–¥–µ–Ω–Ω—ã–µ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–∏:\n"
                + "\n".join(
                    [f"{user['name']} - {user['url']}" for user in self.found_users]
                )
            )

            for user in self.found_users:
                print(f"\n   ‚≠ê ID: {user['id']}")
                print(f"   ‚≠ê –ò–º—è: {user['name']}")
                print(f"   ‚≠ê –°—Å—ã–ª–∫–∞: {user['url']}")
                print(f"   ‚≠ê –í—Ä–µ–º—è –Ω–∞—Ö–æ–¥–∫–∏: {user['timestamp'][11:19]}")
                print(f"   {'‚îÄ' * 40}")
        else:
            print(f"\n‚ùå –ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å '{self.target_name}' –Ω–µ –Ω–∞–π–¥–µ–Ω")
            print(f"   –≤ –¥–∏–∞–ø–∞–∑–æ–Ω–µ {self.start_id:,} - {self.end_id:,}")
            notify("–ü–æ–∏—Å–∫ –∑–∞–∫–æ–Ω—á–µ–Ω: –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–∏ –Ω–µ –Ω–∞–π–¥–µ–Ω—ã")
        notify(self._error_detail_summary())
        if self.error_ids:
            notify("–ï—Å—Ç—å –æ—à–∏–±–∫–∏ –∑–∞–ø—Ä–æ—Å–æ–≤. –ú–æ–∂–Ω–æ –∑–∞–ø—É—Å—Ç–∏—Ç—å /recheck.")

        print("\n" + "=" * 80)
        print(f"üìÅ –õ–æ–≥ —Å–æ—Ö—Ä–∞–Ω–µ–Ω: {CONFIG['log_file']}")
        if CONFIG["save_progress"]:
            print(f"üíæ –ü—Ä–æ–≥—Ä–µ—Å—Å —Å–æ—Ö—Ä–∞–Ω–µ–Ω: {CONFIG['progress_file']}")
        print("=" * 80)


def run_full_pipeline():
    reset_stop()
    reset_error_state()
    run_stamp = datetime.now().strftime("%Y%m%d_%H%M%S")
    CONFIG["log_file"] = f"search_complete_{run_stamp}.log"
    CONFIG["progress_file"] = f"search_progress_{run_stamp}.json"

    print("\n" + "‚ú®" * 40)
    print("‚ú®      KLEINANZEIGEN –û–ë–™–ï–î–ò–ù–ï–ù–ù–´–ô –ü–û–ò–°–ö      ‚ú®")
    print("‚ú®" * 40 + "\n")

    if CONFIG.get("proxy_url"):
        proxy_ok, proxy_ip = check_proxy_connection()
        if proxy_ok:
            geo = check_proxy_geo()
            if geo:
                notify(
                    "–¢–µ—Å—Ç —Å–æ–µ–¥–∏–Ω–µ–Ω–∏—è –ø—Ä–æ–π–¥–µ–Ω!\n"
                    f"IP: {geo.get('ip')}\n"
                    f"–°—Ç—Ä–∞–Ω–∞/—Ä–µ–≥–∏–æ–Ω: {geo.get('countryCode')}\n"
                    f"–†–µ–≥–∏–æ–Ω: {geo.get('regionName')}\n"
                    f"–ì–æ—Ä–æ–¥: {geo.get('city')}"
                )
            elif proxy_ip:
                notify(f"–ü—Ä–æ–∫—Å–∏ –Ω–∞–π–¥–µ–Ω–æ - —Å–æ–µ–¥–∏–Ω–µ–Ω–∏–µ —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–æ (IP: {proxy_ip})")
            else:
                notify("–ü—Ä–æ–∫—Å–∏ –Ω–∞–π–¥–µ–Ω–æ - —Å–æ–µ–¥–∏–Ω–µ–Ω–∏–µ —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–æ (IP: –Ω–µ–∏–∑–≤–µ—Å—Ç–µ–Ω)")
        else:
            notify("–ü—Ä–æ–∫—Å–∏ –Ω–∞–π–¥–µ–Ω–æ - —Å–æ–µ–¥–∏–Ω–µ–Ω–∏–µ –Ω–µ —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–æ")

    if not CONFIG["target_date"]:
        print("‚ùå –û—à–∏–±–∫–∞: target_date –Ω–µ –º–æ–∂–µ—Ç –±—ã—Ç—å –ø—É—Å—Ç–æ–π")
        return

    if not CONFIG["target_name"] or CONFIG["target_name"].strip() == "":
        print("‚ùå –û—à–∏–±–∫–∞: target_name –Ω–µ –º–æ–∂–µ—Ç –±—ã—Ç—å –ø—É—Å—Ç—ã–º")
        return

    known_id = find_any_id_for_date()
    if not known_id:
        print("‚ùå –ù–µ —É–¥–∞–ª–æ—Å—å –Ω–∞–π—Ç–∏ ID –ø–æ —Ü–µ–ª–µ–≤–æ–π –¥–∞—Ç–µ (—ç—Ç–∞–ø 1)")
        return

    boundaries = find_day_boundaries(known_id)
    if not boundaries:
        print("‚ùå –ù–µ —É–¥–∞–ª–æ—Å—å –Ω–∞–π—Ç–∏ –≥—Ä–∞–Ω–∏—Ü—ã –¥–Ω—è (—ç—Ç–∞–ø 2)")
        return

    start_id, end_id = boundaries
    if start_id > end_id:
        print("‚ùå –û—à–∏–±–∫–∞: START_ID –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å –º–µ–Ω—å—à–µ END_ID")
        return

    search_config = SearchConfig(
        start_id=start_id,
        end_id=end_id,
        target_name=CONFIG["target_name"],
        target_date=CONFIG["target_date"],
    )

    try:
        search = ReliableUserSearch(search_config)
        search.run_search()
        if CONFIG["save_progress"]:
            search.save_progress()
        search.print_final_report()
        cooldown_seconds, reason = search._cooldown_plan()
        set_cooldown(cooldown_seconds, reason)

        if search.missing_ids:
            print("\n‚ö†Ô∏è  –•–æ—Ç–∏—Ç–µ –ø—Ä–æ–≤–µ—Ä–∏—Ç—å –ø—Ä–æ–ø—É—â–µ–Ω–Ω—ã–µ ID?")
            print("   –ó–∞–ø—É—Å—Ç–∏—Ç–µ: python check_missing.py")
    except KeyboardInterrupt:
        print("\n\nüõë –ü–û–ò–°–ö –ü–†–ï–†–í–ê–ù –ü–û–õ–¨–ó–û–í–ê–¢–ï–õ–ï–ú")
        if "search" in locals():
            if CONFIG["save_progress"]:
                search.save_progress()
            search.print_final_report()
            cooldown_seconds, reason = search._cooldown_plan()
            set_cooldown(cooldown_seconds, reason)
    except Exception as e:
        print(f"\nüí• –ö–†–ò–¢–ò–ß–ï–°–ö–ê–Ø –û–®–ò–ë–ö–ê: {e}")
        import traceback

        traceback.print_exc()


if __name__ == "__main__":
    run_full_pipeline()
