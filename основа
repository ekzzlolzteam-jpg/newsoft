#!/usr/bin/env python3
"""
–¢–µ–ª–µ–≥—Ä–∞–º-–±–æ—Ç –¥–ª—è –ø—Ä–∏–µ–º–∞ —Å–∫—Ä–∏–Ω–æ–≤ –ø—Ä–æ—Ñ–∏–ª—è Kleinanzeigen –∏ OCR-–∞–Ω–∞–ª–∏–∑–∞.
–ò–∑–≤–ª–µ–∫–∞–µ—Ç –¥–∞—Ç—É —Ä–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏–∏ (Aktiv seit) –∏ –¥—Ä—É–≥–∏–µ –ø–æ–ª—è, –∑–∞—Ç–µ–º –∏—â–µ—Ç –±–ª–∏–∂–∞–π—à—É—é
–¥–∞—Ç—É —Ä–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏–∏ –≤ –±–∞–∑–µ user_id+date (txt).
"""

from __future__ import annotations

import io
import json
import re
import time
import threading
from dataclasses import dataclass
from datetime import datetime
from pathlib import Path
from typing import Iterable, Optional

import python as account_search

import requests
from PIL import Image
import pytesseract

# === –ü–†–ò–ù–£–î–ò–¢–ï–õ–¨–ù–ê–Ø –£–°–¢–ê–ù–û–í–ö–ê –ü–£–¢–ò TESSERACT ===
pytesseract.pytesseract.tesseract_cmd = r"C:\Program Files\Tesseract-OCR\tesseract.exe"

# === CONFIG (—Ä–µ–¥–∞–∫—Ç–∏—Ä—É–π –∑–¥–µ—Å—å) ===
TELEGRAM_BOT_TOKEN = "8501651034:AAH2eoMiqnH05kNJlLf291ru_0aMRLRwmJk"
TELEGRAM_CHAT_IDS = [
    "6478058170",
    "5583690035",
]
POLL_SECONDS = 5  # —É–≤–µ–ª–∏—á–µ–Ω —Å 2
DB_FILE = "known_accounts.txt"  # —Å—Ç—Ä–æ–∫–∏ –≤–∏–¥–∞: user_id;dd.mm.yyyy
TESSERACT_CMD = r"C:\Program Files\Tesseract-OCR\tesseract.exe"  # –ø—É—Ç—å –∫ tesseract.exe
REQUEST_TIMEOUT = 60  # —É–≤–µ–ª–∏—á–µ–Ω —Å 20
STATE_FILE = "bot_state.json"

BADGE_KEYWORDS = [
    "TOP Zufriedenheit",
    "OK Zufriedenheit",
    "Besonders freundlich",
    "Besonders zuverl√§ssig",
    "Sehr freundlich",
    "Sehr zuverl√§ssig",
    "Freundlich",
    "Zuverl√§ssig",
    "Naja",
]

BADGE_TOKENS = {
    "top",
    "zufriedenheit",
    "ok",
    "besonders",
    "sehr",
    "freundlich",
    "zuverl√§ssig",
    "zuverlassig",
}

IGNORE_NAME_KEYWORDS = [
    "Privater Nutzer",
    "Aktiv seit",
    "Anzeigen online",
    "gesamt",
    "Verkaufs√ºbersicht",
    "Antwortet",
    "Follower",
    "Folge ich",
    "Sicher bezahlen",
]


def _clean_name_candidate(line: str) -> Optional[str]:
    cleaned = re.sub(r"[¬©¬Æ‚Ñ¢>]", " ", line)
    cleaned = re.sub(r"\s+", " ", cleaned).strip(" -|")
    if not cleaned:
        return None

    badge_pattern = re.compile(
        r"(top|ok|zufriedenheit|besonders|sehr|freundlich|zuverl[a√§]ssig)",
        re.IGNORECASE,
    )

    words: list[str] = []
    for word in cleaned.split():
        normalized = re.sub(r"[^\w√§√∂√º√Ñ√ñ√ú√ü-]", "", word, flags=re.UNICODE)
        if not normalized:
            continue
        if any(char.isdigit() for char in normalized):
            continue
        lowered = normalized.lower()
        if lowered in BADGE_TOKENS:
            continue
        if badge_pattern.search(lowered):
            continue
        words.append(word)

    if not words:
        return None

    candidate = " ".join(words).strip()
    candidate = re.sub(r"\s{2,}", " ", candidate)
    candidate = candidate.strip(" -|")
    if len(candidate) < 2:
        return None

    if any(keyword.lower() in candidate.lower() for keyword in IGNORE_NAME_KEYWORDS):
        return None

    return candidate


def _format_duration(seconds: int) -> str:
    minutes, secs = divmod(max(0, seconds), 60)
    if minutes > 0:
        return f"{minutes} –º–∏–Ω {secs} —Å–µ–∫"
    return f"{secs} —Å–µ–∫"


def _cooldown_block(chat_id: str) -> bool:
    if hasattr(account_search, "get_cooldown_remaining"):
        remaining = account_search.get_cooldown_remaining()
        if remaining > 0:
            send_message(
                chat_id,
                "–ë–æ—Ç –æ—Ç–¥—ã—Ö–∞–µ—Ç. –û—Å—Ç–∞–ª–æ—Å—å –∂–¥–∞—Ç—å "
                f"{_format_duration(remaining)}.",
            )
            return True
    return False


@dataclass
class ParsedProfile:
    name: Optional[str]
    aktiv_seit: Optional[str]
    online_ads: Optional[int]
    total_ads: Optional[int]
    followers: Optional[int]
    badges: list[str]
    response_status: Optional[str] = None


@dataclass
class BotState:
    mode: Optional[str] = None
    pending_text: Optional[list[str]] = None
    last_update_id: Optional[int] = None
    awaiting_confirm: bool = False
    pending_summary: Optional[str] = None
    pending_profile: Optional[dict] = None


SEARCH_LOCK = threading.Lock()
TEXT_FIELDS = [
    "–ò–º—è",
    "–î–∞—Ç–∞ —Ä–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏–∏",
    "–ü–ª–∞—à–∫–∏ (–∏–ª–∏ '-')",
    "–ü–æ–¥–ø–∏—Å—á–∏–∫–∏ (–∏–ª–∏ '-')",
    "–û–±—ä—è–≤–ª–µ–Ω–∏—è –æ–Ω–ª–∞–π–Ω (–∏–ª–∏ '-')",
]


def _parse_date(date_str: str) -> Optional[str]:
    date_str = date_str.strip().replace("/", ".")
    for fmt in ("%d.%m.%Y", "%d.%m.%y"):
        try:
            return datetime.strptime(date_str, fmt).strftime("%d.%m.%Y")
        except ValueError:
            continue
    return None


def _to_ordinal(date_str: str) -> int:
    return datetime.strptime(date_str, "%d.%m.%Y").toordinal()


def load_state() -> BotState:
    path = Path(STATE_FILE)
    if not path.exists():
        return BotState()
    try:
        data = json.loads(path.read_text(encoding="utf-8"))
    except (json.JSONDecodeError, OSError):
        return BotState()
    return BotState(
        mode=data.get("mode"),
        pending_text=data.get("pending_text"),
        last_update_id=data.get("last_update_id"),
        awaiting_confirm=data.get("awaiting_confirm", False),
        pending_summary=data.get("pending_summary"),
        pending_profile=data.get("pending_profile"),
    )


def save_state(state: BotState) -> None:
    payload = {
        "mode": state.mode,
        "pending_text": state.pending_text,
        "last_update_id": state.last_update_id,
        "awaiting_confirm": state.awaiting_confirm,
        "pending_summary": state.pending_summary,
        "pending_profile": state.pending_profile,
    }
    Path(STATE_FILE).write_text(json.dumps(payload, ensure_ascii=False, indent=2), encoding="utf-8")


def _serialize_profile(profile: ParsedProfile) -> dict:
    return {
        "name": profile.name,
        "aktiv_seit": profile.aktiv_seit,
        "online_ads": profile.online_ads,
        "total_ads": profile.total_ads,
        "followers": profile.followers,
        "badges": profile.badges,
        "response_status": profile.response_status,
    }


def _deserialize_profile(payload: dict) -> ParsedProfile:
    return ParsedProfile(
        name=payload.get("name"),
        aktiv_seit=payload.get("aktiv_seit"),
        online_ads=payload.get("online_ads"),
        total_ads=payload.get("total_ads"),
        followers=payload.get("followers"),
        badges=payload.get("badges", []),
        response_status=payload.get("response_status"),
    )


def load_known_accounts(path: Path) -> list[tuple[str, str]]:
    if not path.exists():
        return []
    rows: list[tuple[str, str]] = []
    for line in path.read_text(encoding="utf-8").splitlines():
        if not line.strip():
            continue
        if ";" not in line:
            continue
        user_id, date_str = [part.strip() for part in line.split(";", 1)]
        normalized = _parse_date(date_str)
        if user_id and normalized:
            rows.append((user_id, normalized))
    return rows


def add_known_account(path: Path, user_id: str, date_str: str) -> None:
    normalized = _parse_date(date_str)
    if not normalized:
        return
    entry = f"{user_id};{normalized}"
    existing = path.read_text(encoding="utf-8").splitlines() if path.exists() else []
    if entry in existing:
        return
    with path.open("a", encoding="utf-8") as handle:
        handle.write(entry + "\n")


def find_nearest_account(
    target_date: str, entries: Iterable[tuple[str, str]]
) -> Optional[tuple[str, str]]:
    target_ord = _to_ordinal(target_date)
    best: Optional[tuple[str, str]] = None
    best_delta: Optional[int] = None
    for user_id, date_str in entries:
        delta = abs(_to_ordinal(date_str) - target_ord)
        if best_delta is None or delta < best_delta:
            best_delta = delta
            best = (user_id, date_str)
    return best


def ocr_image(image_bytes: bytes) -> str:
    if TESSERACT_CMD:
        pytesseract.pytesseract.tesseract_cmd = TESSERACT_CMD
    image = Image.open(io.BytesIO(image_bytes))
    return pytesseract.image_to_string(image, lang="deu+eng")


def extract_profile(text: str) -> ParsedProfile:
    aktiv_match = re.search(
        r"Aktiv\s*seit\s*(\d{1,2}[./]\d{1,2}[./]\d{2,4})",
        text,
        re.IGNORECASE,
    )
    aktiv_seit = _parse_date(aktiv_match.group(1)) if aktiv_match else None

    online_total_match = re.search(
        r"(\d+)\s+Anzeigen\s+online\s*/\s*(\d+)\s+gesamt",
        text,
        re.IGNORECASE,
    )
    online_ads = None
    total_ads = None
    if online_total_match:
        online_ads = int(online_total_match.group(1))
        total_ads = int(online_total_match.group(2))
    else:
        online_only = re.search(
            r"(\d+)\s+Anzeigen\s+online",
            text,
            re.IGNORECASE,
        )
        if online_only:
            online_ads = int(online_only.group(1))

    followers_match = re.search(r"(\d+)\s+Follower", text, re.IGNORECASE)
    followers = int(followers_match.group(1)) if followers_match else None

    normalized_text = re.sub(r"\s+", " ", text).lower()
    badges = [badge for badge in BADGE_KEYWORDS if badge.lower() in normalized_text]
    combo_badges = [
        ("sehr", "freundlich", "Sehr freundlich"),
        ("sehr", "zuverl√§ssig", "Sehr zuverl√§ssig"),
        ("besonders", "freundlich", "Besonders freundlich"),
        ("besonders", "zuverl√§ssig", "Besonders zuverl√§ssig"),
    ]
    for first, second, label in combo_badges:
        if first in normalized_text and second in normalized_text and label not in badges:
            badges.append(label)

    if "Sehr freundlich" in badges and "Freundlich" in badges:
        badges.remove("Freundlich")
    if "Sehr zuverl√§ssig" in badges and "Zuverl√§ssig" in badges:
        badges.remove("Zuverl√§ssig")

    badge_pattern = re.compile(
        "|".join(re.escape(badge) for badge in BADGE_KEYWORDS),
        re.IGNORECASE,
    )

    name = None
    for raw_line in text.splitlines():
        line = raw_line.strip()
        if not line:
            continue
        if any(keyword.lower() in line.lower() for keyword in IGNORE_NAME_KEYWORDS):
            continue
        if len(line) < 2:
            continue

        cleaned_line = badge_pattern.sub("", line)
        candidate = _clean_name_candidate(cleaned_line)
        if not candidate:
            continue
        name = candidate
        break

    return ParsedProfile(
        name=name,
        aktiv_seit=aktiv_seit,
        online_ads=online_ads,
        total_ads=total_ads,
        followers=followers,
        badges=badges,
    )


def _main_keyboard() -> dict:
    return {
        "keyboard": [
            [{"text": "/photo"}, {"text": "/text"}],
            [{"text": "/stats"}, {"text": "/recheck"}],
            [{"text": "/help"}],
            [{"text": "/stop"}, {"text": "/cancel"}],
        ],
        "resize_keyboard": True,
        "one_time_keyboard": False,
    }


def send_message(chat_id: str, text: str, show_keyboard: bool = True) -> None:
    url = f"https://api.telegram.org/bot{TELEGRAM_BOT_TOKEN}/sendMessage"
    payload = {"chat_id": chat_id, "text": text}
    if show_keyboard:
        payload["reply_markup"] = json.dumps(_main_keyboard(), ensure_ascii=False)
    try:
        response = requests.post(url, data=payload, timeout=REQUEST_TIMEOUT)
        response.raise_for_status()
    except requests.exceptions.RequestException as e:
        print(f"‚ö†Ô∏è –û—à–∏–±–∫–∞ –æ—Ç–ø—Ä–∞–≤–∫–∏ —Å–æ–æ–±—â–µ–Ω–∏—è: {e}")


def send_message_to_all(text: str) -> None:
    for chat_id in TELEGRAM_CHAT_IDS:
        send_message(chat_id, text)


def download_file(file_id: str) -> bytes:
    meta_url = f"https://api.telegram.org/bot{TELEGRAM_BOT_TOKEN}/getFile"
    try:
        meta = requests.get(meta_url, params={"file_id": file_id}, timeout=REQUEST_TIMEOUT)
        meta.raise_for_status()
        file_path = meta.json()["result"]["file_path"]
        file_url = f"https://api.telegram.org/file/bot{TELEGRAM_BOT_TOKEN}/{file_path}"
        response = requests.get(file_url, timeout=REQUEST_TIMEOUT)
        response.raise_for_status()
        return response.content
    except requests.exceptions.RequestException as e:
        print(f"‚ö†Ô∏è –û—à–∏–±–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∏ —Ñ–∞–π–ª–∞: {e}")
        raise


def format_summary(parsed: ParsedProfile) -> str:
    lines = [
        "–†–∞—Å–ø–æ–∑–Ω–∞–Ω–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ:",
        f"–ò–º—è: {parsed.name or '–Ω–µ –Ω–∞–π–¥–µ–Ω–æ'}",
        f"–î–∞—Ç–∞ —Ä–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏–∏: {parsed.aktiv_seit or '–Ω–µ –Ω–∞–π–¥–µ–Ω–∞'}",
        f"–û–±—ä—è–≤–ª–µ–Ω–∏—è –æ–Ω–ª–∞–π–Ω: {parsed.online_ads if parsed.online_ads is not None else '–Ω–µ –Ω–∞–π–¥–µ–Ω–æ'}",
        f"–í—Å–µ–≥–æ –æ–±—ä—è–≤–ª–µ–Ω–∏–π: {parsed.total_ads if parsed.total_ads is not None else '–Ω–µ –Ω–∞–π–¥–µ–Ω–æ'}",
        f"–ü–æ–¥–ø–∏—Å—á–∏–∫–∏: {parsed.followers if parsed.followers is not None else '–Ω–µ –Ω–∞–π–¥–µ–Ω–æ'}",
        f"–û—Ç–≤–µ—Ç: {parsed.response_status or '–Ω–µ –Ω–∞–π–¥–µ–Ω–æ'}",
        f"–ü–ª–∞—à–∫–∏: {', '.join(parsed.badges) if parsed.badges else '–Ω–µ –Ω–∞–π–¥–µ–Ω—ã'}",
    ]
    return "\n".join(lines)


def format_copy_text(parsed: ParsedProfile) -> str:
    lines = [
        f"–ò–º—è: {parsed.name or '–Ω–µ –Ω–∞–π–¥–µ–Ω–æ'}",
        f"–î–∞—Ç–∞ —Ä–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏–∏: {parsed.aktiv_seit or '–Ω–µ –Ω–∞–π–¥–µ–Ω–∞'}",
        f"–û–±—ä—è–≤–ª–µ–Ω–∏—è –æ–Ω–ª–∞–π–Ω: {parsed.online_ads if parsed.online_ads is not None else '–Ω–µ –Ω–∞–π–¥–µ–Ω–æ'}",
        f"–í—Å–µ–≥–æ –æ–±—ä—è–≤–ª–µ–Ω–∏–π: {parsed.total_ads if parsed.total_ads is not None else '–Ω–µ –Ω–∞–π–¥–µ–Ω–æ'}",
        f"–ü–æ–¥–ø–∏—Å—á–∏–∫–∏: {parsed.followers if parsed.followers is not None else '–Ω–µ –Ω–∞–π–¥–µ–Ω–æ'}",
        f"–û—Ç–≤–µ—Ç: {parsed.response_status or '–Ω–µ –Ω–∞–π–¥–µ–Ω–æ'}",
        f"–ü–ª–∞—à–∫–∏: {', '.join(parsed.badges) if parsed.badges else '–Ω–µ –Ω–∞–π–¥–µ–Ω—ã'}",
    ]
    return "\n".join(lines)


def _parse_optional_int(value: str) -> Optional[int]:
    cleaned = value.strip().lower()
    if cleaned in {"–Ω–µ –Ω–∞–π–¥–µ–Ω–æ", "–Ω–µ –Ω–∞–π–¥–µ–Ω—ã", "–Ω–µ—Ç", "-"}:
        return None
    match = re.search(r"\d+", cleaned)
    return int(match.group(0)) if match else None


def _parse_badges(value: str) -> list[str]:
    cleaned = value.strip()
    if cleaned.lower() in {"–Ω–µ –Ω–∞–π–¥–µ–Ω—ã", "–Ω–µ –Ω–∞–π–¥–µ–Ω–æ", "–Ω–µ—Ç", "-"}:
        return []
    parts = [part.strip() for part in cleaned.split(",") if part.strip()]
    return parts


def _parse_optional_value(value: Optional[str]) -> Optional[str]:
    if value is None:
        return None
    cleaned = value.strip()
    if cleaned == "-" or cleaned.lower() in {"–Ω–µ—Ç", "–Ω–µ –Ω–∞–π–¥–µ–Ω–æ", "–Ω–µ –Ω–∞–π–¥–µ–Ω—ã"}:
        return None
    return cleaned


def parse_profile_from_lines(lines: list[str]) -> Optional[ParsedProfile]:
    cleaned = [line.strip() for line in lines if line.strip()]
    if len(cleaned) < 2:
        return None

    name = cleaned[0]
    aktiv_seit = _parse_date(cleaned[1])
    if not aktiv_seit:
        return None

    badges_raw = _parse_optional_value(cleaned[2]) if len(cleaned) > 2 else None
    followers_raw = _parse_optional_value(cleaned[3]) if len(cleaned) > 3 else None
    online_raw = _parse_optional_value(cleaned[4]) if len(cleaned) > 4 else None

    badges = _parse_badges(badges_raw) if badges_raw else []
    followers = _parse_optional_int(followers_raw) if followers_raw else None
    online_ads = _parse_optional_int(online_raw) if online_raw else None

    return ParsedProfile(
        name=name,
        aktiv_seit=aktiv_seit,
        online_ads=online_ads,
        total_ads=None,
        followers=followers,
        badges=badges,
    )


def parse_profile_from_text(text: str) -> Optional[ParsedProfile]:
    fields = {}
    for raw_line in text.splitlines():
        line = raw_line.strip()
        if not line or ":" not in line:
            continue
        key, value = [part.strip() for part in line.split(":", 1)]
        fields[key.lower()] = value

    name = fields.get("–∏–º—è")
    aktiv_raw = fields.get("–¥–∞—Ç–∞ —Ä–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏–∏")
    if not name or not aktiv_raw:
        return None

    aktiv_seit = _parse_date(aktiv_raw)
    if not aktiv_seit:
        return None

    online_ads = _parse_optional_int(fields.get("–æ–±—ä—è–≤–ª–µ–Ω–∏—è –æ–Ω–ª–∞–π–Ω", ""))
    total_ads = _parse_optional_int(fields.get("–≤—Å–µ–≥–æ –æ–±—ä—è–≤–ª–µ–Ω–∏–π", ""))
    followers = _parse_optional_int(fields.get("–ø–æ–¥–ø–∏—Å—á–∏–∫–∏", ""))
    response_status = fields.get("–æ—Ç–≤–µ—Ç")
    badges = _parse_badges(fields.get("–ø–ª–∞—à–∫–∏", ""))

    return ParsedProfile(
        name=name,
        aktiv_seit=aktiv_seit,
        online_ads=online_ads,
        total_ads=total_ads,
        followers=followers,
        badges=badges,
        response_status=response_status,
    )


def process_profile(chat_id: str, parsed: ParsedProfile, state: BotState) -> None:
    summary = format_summary(parsed)
    copy_text = format_copy_text(parsed)
    prompt = (
        f"{summary}\n\n"
        "–ï—Å–ª–∏ –¥–∞–Ω–Ω—ã–µ –Ω–µ –≤–µ—Ä–Ω—ã ‚Äî –æ—Ç–ø—Ä–∞–≤—å—Ç–µ –∏—Å–ø—Ä–∞–≤–ª–µ–Ω–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ.\n"
        "–ï—Å–ª–∏ –≤–µ—Ä–Ω—ã ‚Äî –ø—Ä–æ–¥—É–±–ª–∏—Ä—É–π—Ç–µ —ç—Ç–æ —Å–æ–æ–±—â–µ–Ω–∏–µ."
    )
    state.awaiting_confirm = True
    state.pending_summary = summary
    state.pending_profile = _serialize_profile(parsed)
    send_message(chat_id, prompt)
    send_message(
        chat_id,
        "–î–∞–Ω–Ω—ã–µ –¥–ª—è –∫–æ–ø–∏—Ä–æ–≤–∞–Ω–∏—è (–º–æ–∂–Ω–æ –ø–µ—Ä–µ—Å–ª–∞—Ç—å/—Å–∫–æ–ø–∏—Ä–æ–≤–∞—Ç—å —Ü–µ–ª–∏–∫–æ–º):\n"
        f"{copy_text}",
    )


def process_confirmed_profile(chat_id: str, parsed: ParsedProfile) -> None:
    summary = format_summary(parsed)
    copy_text = format_copy_text(parsed)
    send_message(chat_id, summary)
    send_message(
        chat_id,
        "–î–∞–Ω–Ω—ã–µ –¥–ª—è –∫–æ–ø–∏—Ä–æ–≤–∞–Ω–∏—è (–º–æ–∂–Ω–æ –ø–µ—Ä–µ—Å–ª–∞—Ç—å/—Å–∫–æ–ø–∏—Ä–æ–≤–∞—Ç—å —Ü–µ–ª–∏–∫–æ–º):\n"
        f"{copy_text}",
    )

    if not parsed.aktiv_seit:
        send_message(chat_id, "–ù–µ —É–¥–∞–ª–æ—Å—å –æ–ø—Ä–µ–¥–µ–ª–∏—Ç—å –¥–∞—Ç—É —Ä–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏–∏.")
        return

    db_path = Path(DB_FILE)
    entries = load_known_accounts(db_path)
    if not entries:
        send_message(
            chat_id,
            "–ë–∞–∑–∞ –ø—É—Å—Ç–∞—è. –î–æ–±–∞–≤—å –∑–∞–ø–∏—Å—å –≤–∏–¥–∞ user_id;dd.mm.yyyy –≤ known_accounts.txt.",
        )
        return

    nearest = find_nearest_account(parsed.aktiv_seit, entries)
    if not nearest:
        send_message(chat_id, "–ù–µ —É–¥–∞–ª–æ—Å—å –Ω–∞–π—Ç–∏ –±–ª–∏–∂–∞–π—à–∏–π –∞–∫–∫–∞—É–Ω—Ç –≤ –±–∞–∑–µ.")
        return

    user_id, date_str = nearest
    send_message(
        chat_id,
        (
            "–ë–ª–∏–∂–∞–π—à–∞—è –∑–∞–ø–∏—Å—å –≤ –±–∞–∑–µ:\n"
            f"user_id: {user_id}\n"
            f"–î–∞—Ç–∞: {date_str}\n"
            "–≠—Ç–∏ –¥–∞–Ω–Ω—ã–µ –±—É–¥—É—Ç —Å—Ç–∞—Ä—Ç–æ–≤–æ–π —Ç–æ—á–∫–æ–π –¥–ª—è –¥–∞–ª—å–Ω–µ–π—à–µ–≥–æ –ø–æ–∏—Å–∫–∞."
        ),
    )
    send_message(chat_id, "–ó–∞–ø—É—Å–∫–∞—é –ø–æ–∏—Å–∫ –∞–∫–∫–∞—É–Ω—Ç–∞...")
    start_search_thread(parsed, user_id, date_str, chat_id)


def start_search_thread(
    parsed: ParsedProfile,
    user_id: str,
    date_str: str,
    chat_id: str,
) -> None:
    def _run() -> None:
        with SEARCH_LOCK:
            try:
                account_search.set_notify_callback(
                    lambda message: send_message_to_all(message)
                )
                account_search.CONFIG["start_id"] = int(user_id)
                account_search.CONFIG["start_date"] = date_str
                account_search.CONFIG["target_date"] = parsed.aktiv_seit
                account_search.CONFIG["target_name"] = parsed.name or ""
                account_search.run_full_pipeline()
            except Exception as exc:
                send_message(chat_id, f"–û—à–∏–±–∫–∞ –∑–∞–ø—É—Å–∫–∞ –ø–æ–∏—Å–∫–∞: {exc}")

    thread = threading.Thread(target=_run, daemon=True)
    thread.start()


def handle_photo(chat_id: str, file_id: str, state: BotState) -> None:
    try:
        image_bytes = download_file(file_id)
        ocr_text = ocr_image(image_bytes)
        parsed = extract_profile(ocr_text)
        process_profile(chat_id, parsed, state)
    except Exception as e:
        print(f"‚ö†Ô∏è –û—à–∏–±–∫–∞ –æ–±—Ä–∞–±–æ—Ç–∫–∏ —Ñ–æ—Ç–æ: {e}")
        send_message(chat_id, f"–û—à–∏–±–∫–∞ –æ–±—Ä–∞–±–æ—Ç–∫–∏ —Ñ–æ—Ç–æ: {e}")
    finally:
        if not state.awaiting_confirm:
            send_message(chat_id, "–û–∂–∏–¥–∞–Ω–∏–µ –Ω–æ–≤–æ–π –∫–æ–º–∞–Ω–¥—ã (/photo –∏–ª–∏ /text)...")


def handle_command(chat_id: str, text: str, state: BotState) -> None:
    if _cooldown_block(chat_id):
        return
    if text.startswith("/add "):
        parts = text.split()
        if len(parts) < 3:
            send_message(chat_id, "–§–æ—Ä–º–∞—Ç: /add <user_id> <dd.mm.yyyy>")
            return
        user_id = parts[1]
        date_str = parts[2]
        try:
            add_known_account(Path(DB_FILE), user_id, date_str)
            send_message(chat_id, f"–î–æ–±–∞–≤–ª–µ–Ω–æ –≤ –±–∞–∑—É: {user_id};{date_str}")
        except Exception as e:
            send_message(chat_id, f"–û—à–∏–±–∫–∞ –¥–æ–±–∞–≤–ª–µ–Ω–∏—è: {e}")
        return

    if text in {"/cancel", "/clear"}:
        state.mode = None
        state.pending_text = None
        state.awaiting_confirm = False
        state.pending_summary = None
        state.pending_profile = None
        send_message(chat_id, "–í–≤–æ–¥ –æ—á–∏—â–µ–Ω. –í–≤–µ–¥–∏—Ç–µ –Ω–æ–≤—É—é –∫–æ–º–∞–Ω–¥—É (/photo –∏–ª–∏ /text).")
        return

    if text == "/stop":
        state.mode = None
        state.pending_text = None
        state.awaiting_confirm = False
        state.pending_summary = None
        state.pending_profile = None
        if hasattr(account_search, "request_stop"):
            account_search.request_stop()
        stats = None
        if hasattr(account_search, "get_stats_summary"):
            stats = account_search.get_stats_summary()
        if stats:
            send_message(chat_id, f"–ü–æ–∏—Å–∫ –æ—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω.\n{stats}")
        else:
            send_message(chat_id, "–ü–æ–∏—Å–∫ –æ—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω. –í–≤–µ–¥–∏—Ç–µ –Ω–æ–≤—É—é –∫–æ–º–∞–Ω–¥—É (/photo –∏–ª–∏ /text).")
        return

    if text == "/photo":
        state.mode = "photo"
        state.pending_text = None
        state.awaiting_confirm = False
        state.pending_summary = None
        state.pending_profile = None
        send_message(chat_id, "–û–∂–∏–¥–∞—é —Å–∫—Ä–∏–Ω—à–æ—Ç –ø—Ä–æ—Ñ–∏–ª—è. –û—Ç–ø—Ä–∞–≤—å—Ç–µ —Ñ–æ—Ç–æ.")
        return

    if text == "/text":
        state.mode = "text"
        state.pending_text = []
        state.awaiting_confirm = False
        state.pending_summary = None
        state.pending_profile = None
        send_message(
            chat_id,
            (
                "–í–≤–µ–¥–∏—Ç–µ –≤—Ä—É—á–Ω—É—é –ø–æ –æ–¥–Ω–æ–π —Å—Ç—Ä–æ–∫–µ –≤ —Ç–∞–∫–æ–º –ø–æ—Ä—è–¥–∫–µ:\n"
                "1) –ò–º—è (–æ–±—è–∑–∞—Ç–µ–ª—å–Ω–æ)\n"
                "2) –î–∞—Ç–∞ —Ä–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏–∏ (–æ–±—è–∑–∞—Ç–µ–ª—å–Ω–æ)\n"
                "3) –ü–ª–∞—à–∫–∏ (–∏–ª–∏ '-')\n"
                "4) –ü–æ–¥–ø–∏—Å—á–∏–∫–∏ (–∏–ª–∏ '-')\n"
                "5) –û–±—ä—è–≤–ª–µ–Ω–∏—è –æ–Ω–ª–∞–π–Ω (–∏–ª–∏ '-')"
            ),
        )
        return

    if text == "/stats":
        stats = None
        if hasattr(account_search, "get_stats_summary"):
            stats = account_search.get_stats_summary()
        if stats:
            send_message(chat_id, stats)
        else:
            send_message(chat_id, "–°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞ –Ω–µ–¥–æ—Å—Ç—É–ø–Ω–∞. –ü–æ–∏—Å–∫ –µ—â—ë –Ω–µ –∑–∞–ø—É—â–µ–Ω.")
        return

    if text == "/help":
        send_message(
            chat_id,
            (
                "–î–æ—Å—Ç—É–ø–Ω—ã–µ –∫–Ω–æ–ø–∫–∏:\n"
                "/photo ‚Äî –æ—Ç–ø—Ä–∞–≤–∏—Ç—å —Å–∫—Ä–∏–Ω—à–æ—Ç –ø—Ä–æ—Ñ–∏–ª—è –¥–ª—è OCR –∏ –∑–∞–ø—É—Å–∫–∞ –ø–æ–∏—Å–∫–∞\n"
                "/text ‚Äî –≤–≤–µ—Å—Ç–∏ –¥–∞–Ω–Ω—ã–µ –≤—Ä—É—á–Ω—É—é –ø–æ —Å—Ç—Ä–æ–∫–∞–º (–∏–º—è/–¥–∞—Ç–∞/–ø–ª–∞—à–∫–∏/–ø–æ–¥–ø–∏—Å—á–∏–∫–∏/–æ–±—ä—è–≤–ª–µ–Ω–∏—è)\n"
                "/stats ‚Äî –ø–æ–∫–∞–∑–∞—Ç—å —Ç–µ–∫—É—â–∏–π –ø—Ä–æ–≥—Ä–µ—Å—Å –ø–æ–∏—Å–∫–∞\n"
                "/recheck ‚Äî –ø–æ–≤—Ç–æ—Ä–Ω–æ –ø—Ä–æ–≤–µ—Ä–∏—Ç—å ID —Å –æ—à–∏–±–∫–∞–º–∏\n"
                "/stop ‚Äî –æ—Å—Ç–∞–Ω–æ–≤–∏—Ç—å —Ç–µ–∫—É—â–∏–π –ø–æ–∏—Å–∫\n"
                "/cancel ‚Äî —Å–±—Ä–æ—Å–∏—Ç—å –≤–≤–æ–¥ –∏ –∂–¥–∞—Ç—å –Ω–æ–≤—É—é –∫–æ–º–∞–Ω–¥—É"
            ),
        )
        return

    if text == "/recheck":
        if not hasattr(account_search, "recheck_errors"):
            send_message(chat_id, "–ü–æ–≤—Ç–æ—Ä–Ω–∞—è –ø—Ä–æ–≤–µ—Ä–∫–∞ –Ω–µ–¥–æ—Å—Ç—É–ø–Ω–∞ –≤ —ç—Ç–æ–º —Ä–µ–∂–∏–º–µ.")
            return

        def _run_recheck() -> None:
            with SEARCH_LOCK:
                try:
                    count = account_search.recheck_errors()
                    if count is None:
                        send_message(chat_id, "–ù–µ—Ç –∞–∫—Ç–∏–≤–Ω–æ–≥–æ –ø–æ–∏—Å–∫–∞ –¥–ª—è –ø–æ–≤—Ç–æ—Ä–Ω–æ–π –ø—Ä–æ–≤–µ—Ä–∫–∏.")
                    elif count == 0:
                        send_message(chat_id, "–û—à–∏–±–æ–∫ –¥–ª—è –ø–æ–≤—Ç–æ—Ä–Ω–æ–π –ø—Ä–æ–≤–µ—Ä–∫–∏ –Ω–µ—Ç.")
                    else:
                        send_message(chat_id, f"–ü–æ–≤—Ç–æ—Ä–Ω–∞—è –ø—Ä–æ–≤–µ—Ä–∫–∞ –∑–∞–ø—É—â–µ–Ω–∞ –¥–ª—è {count} ID.")
                except Exception as exc:
                    send_message(chat_id, f"–û—à–∏–±–∫–∞ –ø–æ–≤—Ç–æ—Ä–Ω–æ–π –ø—Ä–æ–≤–µ—Ä–∫–∏: {exc}")

        thread = threading.Thread(target=_run_recheck, daemon=True)
        thread.start()
        return

    if state.mode == "text":
        incoming_lines = [line.strip() for line in text.splitlines() if line.strip()]
        state.pending_text = state.pending_text or []
        state.pending_text.extend(incoming_lines)

        if len(state.pending_text) < len(TEXT_FIELDS):
            next_index = len(state.pending_text)
            send_message(chat_id, f"–í–≤–µ–¥–∏—Ç–µ: {TEXT_FIELDS[next_index]}")
            return

        parsed = parse_profile_from_lines(state.pending_text[: len(TEXT_FIELDS)])
        if not parsed:
            send_message(
                chat_id,
                (
                    "–ù–µ —É–¥–∞–ª–æ—Å—å —Ä–∞—Å–ø–æ–∑–Ω–∞—Ç—å –≤–≤–æ–¥. –ü—Ä–æ–≤–µ—Ä—å—Ç–µ –ø–æ—Ä—è–¥–æ–∫ —Å—Ç—Ä–æ–∫:\n"
                    "–ò–º—è\n"
                    "–î–∞—Ç–∞ —Ä–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏–∏ (dd.mm.yyyy)\n"
                    "–ü–ª–∞—à–∫–∏ –∏–ª–∏ '-'\n"
                    "–ü–æ–¥–ø–∏—Å—á–∏–∫–∏ –∏–ª–∏ '-'\n"
                    "–û–±—ä—è–≤–ª–µ–Ω–∏—è –æ–Ω–ª–∞–π–Ω –∏–ª–∏ '-'"
                ),
            )
            return

        process_profile(chat_id, parsed, state)
        state.mode = None
        state.pending_text = None
        return

    if state.awaiting_confirm:
        pending_summary = state.pending_summary or ""
        if pending_summary and pending_summary in text:
            if state.pending_profile:
                parsed = _deserialize_profile(state.pending_profile)
                state.awaiting_confirm = False
                state.pending_summary = None
                state.pending_profile = None
                process_confirmed_profile(chat_id, parsed)
                send_message(chat_id, "–û–∂–∏–¥–∞–Ω–∏–µ –Ω–æ–≤–æ–π –∫–æ–º–∞–Ω–¥—ã (/photo –∏–ª–∏ /text)...")
                return
        parsed = parse_profile_from_text(text)
        if not parsed:
            lines = [line.strip() for line in text.splitlines() if line.strip()]
            parsed = parse_profile_from_lines(lines) if len(lines) >= 2 else None
        if not parsed:
            send_message(
                chat_id,
                "–ù–µ –ø–æ–Ω—è–ª –≤–≤–æ–¥. –ü—Ä–∏—à–ª–∏—Ç–µ –∏—Å–ø—Ä–∞–≤–ª–µ–Ω–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ (—Å –ò–º—è: –∏ –î–∞—Ç–∞ —Ä–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏–∏:) "
                "–∏–ª–∏ –ø–æ—Å—Ç—Ä–æ—á–Ω–æ –∫–∞–∫ –≤ /text, –ª–∏–±–æ –ø—Ä–æ–¥—É–±–ª–∏—Ä—É–π—Ç–µ —Ä–∞—Å–ø–æ–∑–Ω–∞–Ω–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ.",
            )
            return
        state.awaiting_confirm = False
        state.pending_summary = None
        state.pending_profile = None
        process_confirmed_profile(chat_id, parsed)
        send_message(chat_id, "–û–∂–∏–¥–∞–Ω–∏–µ –Ω–æ–≤–æ–π –∫–æ–º–∞–Ω–¥—ã (/photo –∏–ª–∏ /text)...")
        return

    parsed = parse_profile_from_text(text)
    if not parsed:
        send_message(
            chat_id,
            "–ö–æ–º–∞–Ω–¥–∞ –Ω–µ —Ä–∞—Å–ø–æ–∑–Ω–∞–Ω–∞. –ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ /photo, /text, /stop, /stats, /recheck –∏–ª–∏ /cancel.",
        )
        return

    process_profile(chat_id, parsed, state)


def get_updates(offset: Optional[int]) -> dict:
    url = f"https://api.telegram.org/bot{TELEGRAM_BOT_TOKEN}/getUpdates"
    params = {"timeout": 60}  # —É–≤–µ–ª–∏—á–µ–Ω long-polling —Ç–∞–π–º–∞—É—Ç
    if offset is not None:
        params["offset"] = offset
    
    try:
        response = requests.get(url, params=params, timeout=REQUEST_TIMEOUT)
        response.raise_for_status()
        return response.json()
    except requests.exceptions.ReadTimeout:
        print("‚ö†Ô∏è –¢–∞–π–º–∞—É—Ç –ø—Ä–∏ –ø–æ–ª—É—á–µ–Ω–∏–∏ –æ–±–Ω–æ–≤–ª–µ–Ω–∏–π. –ü—Ä–æ–¥–æ–ª–∂–∞—é —Ä–∞–±–æ—Ç—É...")
        return {"result": []}
    except requests.exceptions.RequestException as e:
        print(f"‚ö†Ô∏è –û—à–∏–±–∫–∞ —Å–æ–µ–¥–∏–Ω–µ–Ω–∏—è: {e}")
        return {"result": []}


def main() -> None:
    allowed = set(TELEGRAM_CHAT_IDS)
    state = load_state()
    offset = state.last_update_id + 1 if state.last_update_id is not None else None
    error_count = 0

    print("ü§ñ –ë–æ—Ç –∑–∞–ø—É—â–µ–Ω –∏ –æ–∂–∏–¥–∞–µ—Ç –∫–æ–º–∞–Ω–¥—ã...")
    print(f"üìÅ –ë–∞–∑–∞ –¥–∞–Ω–Ω—ã—Ö: {DB_FILE}")
    print(f"üîß Tesseract –ø—É—Ç—å: {TESSERACT_CMD}")
    print("üì∏ –ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ –∫–æ–º–∞–Ω–¥—ã /photo –∏–ª–∏ /text")

    while True:
        try:
            updates = get_updates(offset)
            
            if "result" in updates:
                for update in updates["result"]:
                    offset = update["update_id"] + 1
                    state.last_update_id = update["update_id"]
                    message = update.get("message")
                    if not message:
                        continue
                    
                    chat_id = str(message["chat"]["id"])
                    if chat_id not in allowed:
                        continue
                    
                    if "text" in message:
                        handle_command(chat_id, message["text"].strip(), state)
                        save_state(state)
                    
                    if "photo" in message:
                        if _cooldown_block(chat_id):
                            continue
                        if state.mode != "photo":
                            send_message(
                                chat_id,
                                "–°–Ω–∞—á–∞–ª–∞ –æ—Ç–ø—Ä–∞–≤—å—Ç–µ –∫–æ–º–∞–Ω–¥—É /photo, –∑–∞—Ç–µ–º —Å–∫—Ä–∏–Ω—à–æ—Ç.",
                            )
                            continue
                        file_id = message["photo"][-1]["file_id"]
                        print(f"üì∏ –ü–æ–ª—É—á–µ–Ω–æ —Ñ–æ—Ç–æ –æ—Ç {chat_id}, –æ–±—Ä–∞–±–æ—Ç–∫–∞...")
                        handle_photo(chat_id, file_id, state)
                        state.mode = None
                        state.pending_text = None
                        save_state(state)
            
            error_count = 0  # —Å–±—Ä–∞—Å—ã–≤–∞–µ–º —Å—á–µ—Ç—á–∏–∫ –æ—à–∏–±–æ–∫
            time.sleep(POLL_SECONDS)
            
        except KeyboardInterrupt:
            print("\nüëã –û—Å—Ç–∞–Ω–æ–≤–∫–∞ –±–æ—Ç–∞...")
            break
        except Exception as e:
            error_count += 1
            print(f"‚ö†Ô∏è –û—à–∏–±–∫–∞ –≤ –æ—Å–Ω–æ–≤–Ω–æ–º —Ü–∏–∫–ª–µ ({error_count}): {e}")
            
            if error_count > 10:
                print("üîÑ –°–ª–∏—à–∫–æ–º –º–Ω–æ–≥–æ –æ—à–∏–±–æ–∫, –ø–µ—Ä–µ–∑–∞–ø—É—Å–∫ —á–µ—Ä–µ–∑ 30 —Å–µ–∫—É–Ω–¥...")
                time.sleep(30)
                error_count = 0
            else:
                time.sleep(10)  # –∂–¥–µ–º –ø–µ—Ä–µ–¥ —Å–ª–µ–¥—É—é—â–µ–π –ø–æ–ø—ã—Ç–∫–æ–π


if __name__ == "__main__":
    main()
