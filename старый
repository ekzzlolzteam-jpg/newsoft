1.py](https://github.com/user-attachments/files/24986335/1.py)
import requests
import re
import time
import sys
from datetime import datetime  # –î–æ–±–∞–≤–ª–µ–Ω –∏–º–ø–æ—Ä—Ç

# === –ö–û–ù–§–ò–ì ===
START_ID = 48075804
START_DATE = "13.06.2017"  # –§–æ—Ä–º–∞—Ç DD.MM.YYYY
TARGET_DATE = "08.02.2017"  # –ò—â–µ–º —ç—Ç—É –¥–∞—Ç—É

# –ù–∞—Å—Ç—Ä–æ–π–∫–∏ –ø–æ–∏—Å–∫–∞
JUMP_MULTIPLIER = 20000    # –ù–∞—á–∞–ª—å–Ω—ã–π –º–Ω–æ–∂–∏—Ç–µ–ª—å –ø—Ä—ã–∂–∫–∞
MAX_ATTEMPTS = 300          # –ú–∞–∫—Å–∏–º—É–º –ø–æ–ø—ã—Ç–æ–∫
PAUSE_SECONDS = 1        # –ü–∞—É–∑–∞ –º–µ–∂–¥—É –∑–∞–ø—Ä–æ—Å–∞–º–∏

# –ö–æ—Ä—Ä–µ–∫—Ç–∏—Ä–æ–≤–∫–∞ —à–∞–≥–∞ (–¥–Ω–µ–π ‚Üí ID)
CORRECTION_STEPS = {
    50: 700000,   # –†–∞–∑–Ω–∏—Ü–∞ >100 –¥–Ω–µ–π ‚Üí —à–∞–≥ 10000 ID
    30: 500000,     # –†–∞–∑–Ω–∏—Ü–∞ >30 –¥–Ω–µ–π ‚Üí —à–∞–≥ 5000 ID
    7: 25000,      # –†–∞–∑–Ω–∏—Ü–∞ >7 –¥–Ω–µ–π ‚Üí —à–∞–≥ 1000 ID
    0: 10000        # –ú–µ–Ω—å—à–∞—è —Ä–∞–∑–Ω–∏—Ü–∞ ‚Üí —à–∞–≥ 500 ID
}
# === –ö–û–ù–ï–¶ –ö–û–ù–§–ò–ì–ê ===

def date_to_days(date_str):
    """–ö–æ–Ω–≤–µ—Ä—Ç–∏—Ä—É–µ—Ç DD.MM.YYYY –≤ –¥–Ω–∏ (–æ–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ—Ç —Ä–∞–∑–Ω—ã–µ —Ñ–æ—Ä–º–∞—Ç—ã)"""
    if not date_str:
        return None
    
    # –û—á–∏—â–∞–µ–º —Å—Ç—Ä–æ–∫—É
    date_str = str(date_str).strip().replace('/', '.').replace('-', '.')
    
    # –ü—Ä–æ–±—É–µ–º —Ä–∞–∑–Ω—ã–µ —Ñ–æ—Ä–º–∞—Ç—ã
    formats = [
        "%d.%m.%Y",  # 17.06.2010
        "%d.%m.%y",  # 17.06.10
        "%Y.%m.%d",  # 2010.06.17 (–æ–±—Ä–∞—Ç–Ω—ã–π)
        "%d-%m-%Y",  # 17-06-2010
    ]
    
    for fmt in formats:
        try:
            date_obj = datetime.strptime(date_str, fmt)
            return date_obj.toordinal()
        except ValueError:
            continue
    
    print(f"ERROR: –ù–µ –º–æ–≥—É —Ä–∞—Å–ø–∞—Ä—Å–∏—Ç—å –¥–∞—Ç—É '{date_str}'")
    return None

def get_date_from_page(user_id, session):
    """–ü–æ–ª—É—á–∞–µ—Ç –¥–∞—Ç—É —Ä–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏–∏ —Å–æ —Å—Ç—Ä–∞–Ω–∏—Ü—ã"""
    url = f"https://www.kleinanzeigen.de/s-bestandsliste.html?userId={user_id}"
    try:
        time.sleep(PAUSE_SECONDS)
        response = session.get(url, timeout=10)
        if response.status_code == 404:
            return None
        
        # –ò—â–µ–º –¥–∞—Ç—É
        match = re.search(r'Aktiv seit\s*(\d{1,2}[./]\d{1,2}[./]\d{2,4})', response.text)
        if match:
            date_str = match.group(1).replace('/', '.')
            # –ü—Ä–æ–±—É–µ–º —Ä–∞—Å–ø–∞—Ä—Å–∏—Ç—å –¥–ª—è –ø—Ä–æ–≤–µ—Ä–∫–∏
            try:
                datetime.strptime(date_str, "%d.%m.%Y")
                return date_str
            except:
                try:
                    datetime.strptime(date_str, "%d.%m.%y")
                    return date_str
                except:
                    return None
        return None
    except:
        return None

def calculate_step(days_diff):
    """–û–ø—Ä–µ–¥–µ–ª—è–µ—Ç —à–∞–≥ –∫–æ—Ä—Ä–µ–∫—Ç–∏—Ä–æ–≤–∫–∏ –ø–æ —Ç–∞–±–ª–∏—Ü–µ"""
    abs_diff = abs(days_diff)
    for threshold in sorted(CORRECTION_STEPS.keys(), reverse=True):
        if abs_diff > threshold:
            return CORRECTION_STEPS[threshold]
    return 500

def main():
    session = requests.Session()
    session.headers = {
        'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36'
    }
    
    print(f"=== –ü–û–ò–°–ö –ü–û–õ–¨–ó–û–í–ê–¢–ï–õ–Ø ===")
    print(f"–ò—â–µ–º –¥–∞—Ç—É: {TARGET_DATE}")
    print(f"–°—Ç–∞—Ä—Ç: ID {START_ID} –æ—Ç {START_DATE}")
    print(f"–ù–∞—Å—Ç—Ä–æ–π–∫–∏: –º–Ω–æ–∂–∏—Ç–µ–ª—å={JUMP_MULTIPLIER}, –ø–∞—É–∑–∞={PAUSE_SECONDS}—Å")
    print(f"–ö–æ—Ä—Ä–µ–∫—Ç–∏—Ä–æ–≤–∫–∏: {CORRECTION_STEPS}")
    print("=" * 40)
    
    # –ü—Ä–æ–≤–µ—Ä—è–µ–º —Å—Ç–∞—Ä—Ç–æ–≤–æ–≥–æ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
    print(f"[1] ID {START_ID} -> ", end='')
    start_date_found = get_date_from_page(START_ID, session)
    if not start_date_found:
        print("–û–®–ò–ë–ö–ê: –ù–µ –≤–∏–¥–∏–º –¥–∞—Ç—É —Å—Ç–∞—Ä—Ç–æ–≤–æ–≥–æ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è!")
        sys.exit(1)
    print(f"{start_date_found}")
    
    # –ü–†–ï–î–£–ü–†–ï–ñ–î–ï–ù–ò–ï: –µ—Å–ª–∏ –¥–∞—Ç–∞ –Ω–µ —Å–æ–≤–ø–∞–¥–∞–µ—Ç
    if start_date_found != START_DATE:
        print(f"–í–ù–ò–ú–ê–ù–ò–ï: –£–∫–∞–∑–∞–ª–∏ {START_DATE}, –∞ –Ω–∞ —Å–∞–π—Ç–µ {start_date_found}")
        print("–ü—Ä–æ–¥–æ–ª–∂–∞–µ–º –ø–æ–∏—Å–∫ —Å –¥–∞—Ç–æ–π —Å —Å–∞–π—Ç–∞...")
        # –ò—Å–ø–æ–ª—å–∑—É–µ–º –Ω–∞–π–¥–µ–Ω–Ω—É—é –¥–∞—Ç—É –¥–ª—è —Ä–∞—Å—á–µ—Ç–æ–≤
        actual_start_date = start_date_found
    else:
        actual_start_date = START_DATE
    
    # –†–∞—Å—á–µ—Ç –Ω–∞—á–∞–ª—å–Ω–æ–≥–æ –ø—Ä—ã–∂–∫–∞
    start_days = date_to_days(actual_start_date)
    target_days = date_to_days(TARGET_DATE)
    
    if not start_days or not target_days:
        print(f"–û—à–∏–±–∫–∞ —Ñ–æ—Ä–º–∞—Ç–∞ –¥–∞—Ç—ã! start_days={start_days}, target_days={target_days}")
        sys.exit(1)
    
    days_diff = start_days - target_days  # –†–∞–∑–Ω–∏—Ü–∞ –≤ –¥–Ω—è—Ö
    initial_jump = days_diff * JUMP_MULTIPLIER
    current_id = START_ID - initial_jump  # ID –ø–æ—Å–ª–µ –ø—Ä—ã–∂–∫–∞
    
    print(f"–†–∞–∑–Ω–∏—Ü–∞: {days_diff} –¥–Ω–µ–π")
    print(f"–ü—Ä—ã–∂–æ–∫: {initial_jump} ID -> –ø—Ä–æ–≤–µ—Ä—è–µ–º ID {current_id}")
    print("-" * 40)
    
    # –û—Å–Ω–æ–≤–Ω–æ–π —Ü–∏–∫–ª –ø–æ–∏—Å–∫–∞
    for attempt in range(2, MAX_ATTEMPTS + 1):
        if current_id <= 0:
            print("ID —Å—Ç–∞–ª –æ—Ç—Ä–∏—Ü–∞—Ç–µ–ª—å–Ω—ã–º!")
            current_id = 1
            continue
            
        print(f"[{attempt}] ID {current_id} -> ", end='', flush=True)
        
        date_found = get_date_from_page(current_id, session)
        
        if date_found is None:
            print("–ù–µ—Ç –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è")
            # –ü–ª–∞–≤–Ω–æ–µ –¥–≤–∏–∂–µ–Ω–∏–µ –≤–ø–µ—Ä–µ–¥/–Ω–∞–∑–∞–¥
            current_id += 1 if days_diff > 0 else -1
            continue
        
        print(f"{date_found}")
        
        # –ü—Ä–æ–≤–µ—Ä—è–µ–º —Å–æ–≤–ø–∞–¥–µ–Ω–∏–µ
        current_days = date_to_days(date_found)
        if not current_days:
            current_id += 100
            continue
            
        if current_days == target_days:
            print("\n" + "=" * 40)
            print(f"–ù–ê–ô–î–ï–ù–û! ID: {current_id}")
            print(f"–î–∞—Ç–∞: {date_found}")
            print(f"–°—Å—ã–ª–∫–∞: https://www.kleinanzeigen.de/s-bestandsliste.html?userId={current_id}")
            print("=" * 40)
            return
        
        # –ö–æ—Ä—Ä–µ–∫—Ç–∏—Ä–æ–≤–∫–∞ –Ω–∞–ø—Ä–∞–≤–ª–µ–Ω–∏—è
        if current_days > target_days:  # –ú—ã –≤ –±—É–¥—É—â–µ–º –æ—Ç–Ω–æ—Å–∏—Ç–µ–ª—å–Ω–æ —Ü–µ–ª–∏
            direction = -1
            diff = current_days - target_days
        else:  # –ú—ã –≤ –ø—Ä–æ—à–ª–æ–º –æ—Ç–Ω–æ—Å–∏—Ç–µ–ª—å–Ω–æ —Ü–µ–ª–∏
            direction = 1
            diff = target_days - current_days
        
        step = calculate_step(diff) * direction
        print(f"    –ö–æ—Ä—Ä–µ–∫—Ç–∏—Ä–æ–≤–∫–∞: {step} ID (—Ä–∞–∑–Ω–∏—Ü–∞ {diff} –¥–Ω–µ–π)")
        current_id += step
    
    print(f"\n–ù–µ –Ω–∞–π–¥–µ–Ω–æ –∑–∞ {MAX_ATTEMPTS} –ø–æ–ø—ã—Ç–æ–∫")
    print(f"–ü–æ—Å–ª–µ–¥–Ω–∏–π ID: {current_id}")

if __name__ == "__main__":
    main()



[2v2.py](https://github.com/user-attachments/files/24986336/2v2.py)
#!/usr/bin/env python3
# ============================================================
# Kleinanzeigen ‚Äî –±—ã—Å—Ç—Ä—ã–π –∏ —Å—Ç–∞–±–∏–ª—å–Ω—ã–π –ø–æ–∏—Å–∫ FIRST / LAST ID
# ============================================================

# =========================
# ========== –ö–û–ù–§–ò–ì =======
# =========================

TARGET_DATE = "08.02.2017"        # DD.MM.YYYY
SEED_ID     = 45210854      # –ª—é–±–æ–π ID —Ä—è–¥–æ–º (–ù–ï –æ–±—è–∑–∞—Ç–µ–ª—å–Ω–æ —ç—Ç–æ–π –¥–∞—Ç—ã)

BASE_URL = "https://www.kleinanzeigen.de/s-bestandsliste.html?userId="

MAX_REQUESTS   = 350
REQUEST_DELAY  = 1           # –º–æ–∂–Ω–æ —Å–Ω–∏–∂–∞—Ç—å, –Ω–æ —Ä–∏—Å–∫ –±–∞–Ω–∞
REQUEST_TIMEOUT = 15

USERS_PER_DAY  = 25000            # –æ—Ü–µ–Ω–∫–∞, –ù–ï —Ç–æ—á–Ω–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ
MIN_JUMP       = 20000            # –º–∏–Ω–∏–º—É–º –ø—Ä—ã–∂–∫–∞
MAX_JUMP       = 1_200_000         # –∑–∞—â–∏—Ç–∞ –æ—Ç —Å–ª–∏—à–∫–æ–º –¥–∞–ª—å–Ω–∏—Ö –ø—Ä—ã–∂–∫–æ–≤

MAX_NEIGHBOR_PROBES = 14           # 1,2,4,8,...
FINAL_SCAN_LIMIT    = 200          # –¥–æ–≤–æ–¥–∫–∞ –≥—Ä–∞–Ω–∏—Ü

PRINT_DETAILS  = True
PRINT_REQUESTS = False

USER_AGENTS = [
    "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/122.0.0.0 Safari/537.36",
    "Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:123.0) Gecko/20100101 Firefox/123.0",
]

# =========================
# ========== –ö–û–î ===========
# =========================

import time, random, re
from datetime import datetime
from typing import Optional, Tuple, Dict
import requests


AKTIV_RE = re.compile(r"Aktiv\s*seit\s*(\d{1,2}[./]\d{1,2}[./]\d{2,4})", re.IGNORECASE)

def norm_date(s: str) -> Optional[str]:
    s = s.replace("/", ".")
    for f in ("%d.%m.%Y", "%d.%m.%y"):
        try:
            return datetime.strptime(s, f).strftime("%d.%m.%Y")
        except ValueError:
            pass
    return None

def ord_date(s: str) -> int:
    return datetime.strptime(s, "%d.%m.%Y").toordinal()


class Finder:
    def __init__(self):
        self.session = requests.Session()
        self.session.headers.update({
            "User-Agent": random.choice(USER_AGENTS),
            "Accept-Language": "de-DE,de;q=0.9",
            "DNT": "1",
        })
        self.req = 0
        self.cache: Dict[int, Optional[str]] = {}

    def log(self, msg: str):
        if PRINT_DETAILS:
            print(f"[{time.strftime('%H:%M:%S')}] {msg}")

    def budget_ok(self) -> bool:
        return self.req < MAX_REQUESTS

    def fetch_date(self, uid: int) -> Optional[str]:
        if uid < 1 or not self.budget_ok():
            return None
        if uid in self.cache:
            return self.cache[uid]

        time.sleep(REQUEST_DELAY)
        try:
            r = self.session.get(f"{BASE_URL}{uid}", timeout=REQUEST_TIMEOUT)
            self.req += 1
            if PRINT_REQUESTS:
                self.log(f"REQ {self.req}/{MAX_REQUESTS}: {uid} -> {r.status_code}")

            if r.status_code != 200:
                self.cache[uid] = None
                return None

            m = AKTIV_RE.search(r.text)
            if not m:
                self.cache[uid] = None
                return None

            d = norm_date(m.group(1))
            self.cache[uid] = d
            return d
        except Exception:
            self.req += 1
            return None

    def nearest_ok(self, uid: int, lo: int, hi: int) -> Tuple[Optional[int], Optional[str]]:
        d = self.fetch_date(uid)
        if d and lo <= uid <= hi:
            return uid, d

        step = 1
        for _ in range(MAX_NEIGHBOR_PROBES):
            for c in (uid-step, uid+step):
                if c < lo or c > hi:
                    continue
                dd = self.fetch_date(c)
                if dd:
                    return c, dd
            step *= 2
        return None, None

    def jump(self, uid: int, days: int, direction: int) -> int:
        step = max(MIN_JUMP, min(days * USERS_PER_DAY, MAX_JUMP))
        return uid + direction * step

    # ---------- 1) –Ω–∞–π—Ç–∏ known_id ----------
    def find_known_id(self) -> Optional[int]:
        tord = ord_date(TARGET_DATE)

        d = self.fetch_date(SEED_ID)
        if d and ord_date(d) == tord:
            self.log(f"‚úÖ known_id: {SEED_ID} = {d}")
            return SEED_ID

        for days in (1, 2, 4, 8, 16, 32, 64, 128):
            for dir_ in (-1, +1):
                cand = self.jump(SEED_ID, days, dir_)
                dd = self.fetch_date(cand)
                if dd and ord_date(dd) == tord:
                    self.log(f"‚úÖ known_id: {cand} = {dd}")
                    return cand

        self.log("‚ùå –ù–µ –Ω–∞–π–¥–µ–Ω known_id ‚Äî –≤–æ–∑—å–º–∏ SEED_ID –±–ª–∏–∂–µ –∫ –¥–∞—Ç–µ")
        return None

    # ---------- FIRST ----------
    def find_first(self, known: int) -> Optional[int]:
        tord = ord_date(TARGET_DATE)
        hi = known

        # –∏—â–µ–º lo < target
        days = 1
        while self.budget_ok():
            cand = self.jump(hi, days, -1)
            cid, cd = self.nearest_ok(cand, 1, hi-1)
            if cid and ord_date(cd) < tord:
                lo = cid
                break
            days *= 2

        # –±–∏–Ω–∞—Ä–∫–∞
        left, right = lo, hi
        while left < right - 1 and self.budget_ok():
            mid = (left + right) // 2
            mid_id, mid_d = self.nearest_ok(mid, left+1, right-1)

            if not mid_id:
                right -= 1
                continue

            if ord_date(mid_d) < tord:
                left = mid_id
            else:
                right = mid_id

            self.log(f"FIRST step: {left} .. {right}")

        # –¥–æ–≤–æ–¥–∫–∞
        cur = right
        for _ in range(FINAL_SCAN_LIMIT):
            pid, pd = self.nearest_ok(cur-1, 1, cur-1)
            if not pid or ord_date(pd) < tord:
                return cur
            cur = pid

        return cur

    # ---------- LAST ----------
    def find_last(self, first: int) -> Optional[int]:
        tord = ord_date(TARGET_DATE)
        lo = first

        days = 1
        while self.budget_ok():
            cand = self.jump(lo, days, +1)
            cid, cd = self.nearest_ok(cand, lo+1, cand + MAX_JUMP)
            if cid and ord_date(cd) > tord:
                hi = cid
                break
            days *= 2

        # –±–∏–Ω–∞—Ä–∫–∞
        left, right = lo, hi
        while left < right - 1 and self.budget_ok():
            mid = (left + right) // 2
            mid_id, mid_d = self.nearest_ok(mid, left+1, right-1)

            if not mid_id:
                left += 1
                continue

            if ord_date(mid_d) <= tord:
                left = mid_id
            else:
                right = mid_id

            self.log(f"LAST step: {left} .. {right}")

        # –¥–æ–≤–æ–¥–∫–∞
        cur = left
        for _ in range(FINAL_SCAN_LIMIT):
            nid, nd = self.nearest_ok(cur+1, cur+1, cur+1 + MAX_JUMP)
            if not nid or ord_date(nd) > tord:
                return cur
            cur = nid

        return cur


def main():
    print("="*70)
    print("üöÄ Kleinanzeigen ‚Äî –ø–æ–∏—Å–∫ –≥—Ä–∞–Ω–∏—Ü —Ä–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏–∏ (stable)")
    print("="*70)
    print(f"–î–∞—Ç–∞   : {TARGET_DATE}")
    print(f"Seed ID: {SEED_ID}")
    print("="*70)

    f = Finder()

    known = f.find_known_id()
    if not known:
        print("‚ùå known_id –Ω–µ –Ω–∞–π–¥–µ–Ω")
        return

    first = f.find_first(known)
    if not first:
        print("‚ùå FIRST_ID –Ω–µ –Ω–∞–π–¥–µ–Ω")
        return

    last = f.find_last(first)
    if not last:
        print("‚ùå LAST_ID –Ω–µ –Ω–∞–π–¥–µ–Ω")
        return

    print("\n" + "="*70)
    print("‚úÖ –†–ï–ó–£–õ–¨–¢–ê–¢")
    print("="*70)
    print(f"KNOWN_ID : {known}")
    print(f"FIRST_ID : {first}")
    print(f"LAST_ID  : {last}")
    print(f"COUNT    : {last-first+1:,}")
    print(f"REQUESTS : {f.req}/{MAX_REQUESTS}")
    print("="*70)


if __name__ == "__main__":
    main()




    [3neu.py](https://github.com/user-attachments/files/24986337/3neu.py)
"""
–ü–∞—Ä—Å–µ—Ä –¥–ª—è –ø–æ–∏—Å–∫–∞ –ö–û–ù–ö–†–ï–¢–ù–û–ì–û –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è –Ω–∞ Kleinanzeigen.de
–ù–∞–¥–µ–∂–Ω–∞—è –≤–µ—Ä—Å–∏—è —Å –ø–æ–ª–Ω—ã–º –∫–æ–Ω—Ç—Ä–æ–ª–µ–º –ø—Ä–æ–ø—É—Å–∫–æ–≤ –∏ —è–≤–Ω—ã–º –æ–ø–æ–≤–µ—â–µ–Ω–∏–µ–º –ø—Ä–∏ –Ω–∞—Ö–æ–¥–∫–µ
"""

import requests
import re
import time
import json
import sys
import logging
from datetime import datetime
from concurrent.futures import ThreadPoolExecutor, as_completed
import threading
from collections import defaultdict
import signal

# ================= –ö–û–ù–§–ò–ì–£–†–ê–¶–ò–Ø =================
START_ID = 17479674
END_ID = 17502395
TARGET_NAME = "Manuela"
TARGET_DATE = ""  # –ù–µ –ø—Ä–æ–≤–µ—Ä—è–µ–º –¥–∞—Ç—É

# –û–ø—Ç–∏–º–∞–ª—å–Ω—ã–µ –Ω–∞—Å—Ç—Ä–æ–π–∫–∏ –¥–ª—è –Ω–∞–¥–µ–∂–Ω–æ—Å—Ç–∏
REQUESTS_PER_SECOND = 15     # –ë–µ–∑–æ–ø–∞—Å–Ω–∞—è —Å–∫–æ—Ä–æ—Å—Ç—å: 15 –∑–∞–ø—Ä/—Å–µ–∫
MAX_WORKERS = 6              # –û–ø—Ç–∏–º–∞–ª—å–Ω–æ–µ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –ø–æ—Ç–æ–∫–æ–≤
BATCH_SIZE = 50              # –†–∞–∑–º–µ—Ä –ø–∞–∫–µ—Ç–∞
TIMEOUT = 10                 # –¢–∞–π–º–∞—É—Ç –∑–∞–ø—Ä–æ—Å–∞ –≤ —Å–µ–∫—É–Ω–¥–∞—Ö

# –ù–∞—Å—Ç—Ä–æ–π–∫–∏ –ª–æ–≥–∏—Ä–æ–≤–∞–Ω–∏—è
LOG_FILE = "search_complete.log"
LOG_LEVEL = logging.INFO
SAVE_PROGRESS = True
PROGRESS_FILE = "search_progress.json"
# ================================================

BASE_URL = "https://www.kleinanzeigen.de/s-bestandsliste.html?userId={user_id}"
HEADERS = {
    'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36',
    'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8',
    'Accept-Language': 'de-DE,de;q=0.9,en-US;q=0.8,en;q=0.7',
    'Accept-Encoding': 'gzip, deflate, br',
    'DNT': '1',
    'Connection': 'keep-alive',
    'Upgrade-Insecure-Requests': '1',
}

class RateLimiter:
    """–ö–æ–Ω—Ç—Ä–æ–ª–µ—Ä —Å–∫–æ—Ä–æ—Å—Ç–∏ –∑–∞–ø—Ä–æ—Å–æ–≤"""
    def __init__(self, requests_per_second):
        self.requests_per_second = requests_per_second
        self.min_interval = 1.0 / requests_per_second
        self.last_request_time = 0
        self.lock = threading.Lock()
    
    def wait(self):
        """–ñ–¥–µ—Ç –Ω–µ–æ–±—Ö–æ–¥–∏–º–æ–µ –≤—Ä–µ–º—è –ø–µ—Ä–µ–¥ —Å–ª–µ–¥—É—é—â–∏–º –∑–∞–ø—Ä–æ—Å–æ–º"""
        with self.lock:
            current_time = time.time()
            elapsed = current_time - self.last_request_time
            
            if elapsed < self.min_interval:
                sleep_time = self.min_interval - elapsed
                time.sleep(sleep_time)
            
            self.last_request_time = time.time()

class SearchLogger:
    """–ö–∞—Å—Ç–æ–º–Ω—ã–π –ª–æ–≥–≥–µ—Ä —Å –∫—Ä–∞—Å–∏–≤—ã–º –≤—ã–≤–æ–¥–æ–º"""
    def __init__(self):
        # –ù–∞—Å—Ç—Ä–æ–π–∫–∞ —Ñ–∞–π–ª–æ–≤–æ–≥–æ –ª–æ–≥–≥–µ—Ä–∞
        file_handler = logging.FileHandler(LOG_FILE, encoding='utf-8')
        file_handler.setFormatter(logging.Formatter('%(asctime)s - %(levelname)s - %(message)s'))
        
        # –ù–∞—Å—Ç—Ä–æ–π–∫–∞ –∫–æ–Ω—Å–æ–ª—å–Ω–æ–≥–æ –ª–æ–≥–≥–µ—Ä–∞
        console_handler = logging.StreamHandler()
        console_handler.setFormatter(logging.Formatter('%(message)s'))
        
        self.logger = logging.getLogger('KleinanzeigenSearch')
        self.logger.setLevel(LOG_LEVEL)
        self.logger.addHandler(file_handler)
        self.logger.addHandler(console_handler)
        
        # –î–ª—è —Ü–≤–µ—Ç–Ω–æ–≥–æ –≤—ã–≤–æ–¥–∞ –≤ –∫–æ–Ω—Å–æ–ª—å
        self.colors = {
            'INFO': '\033[94m',      # –°–∏–Ω–∏–π
            'SUCCESS': '\033[92m',   # –ó–µ–ª–µ–Ω—ã–π
            'WARNING': '\033[93m',   # –ñ–µ–ª—Ç—ã–π
            'ERROR': '\033[91m',     # –ö—Ä–∞—Å–Ω—ã–π
            'DEBUG': '\033[90m',     # –°–µ—Ä—ã–π
            'FOUND': '\033[95m',     # –§–∏–æ–ª–µ—Ç–æ–≤—ã–π
            'FOUND_BANNER': '\033[1;35m',  # –ñ–∏—Ä–Ω—ã–π —Ñ–∏–æ–ª–µ—Ç–æ–≤—ã–π
            'RESET': '\033[0m',      # –°–±—Ä–æ—Å
        }
    
    def log(self, level: str, message: str, user_id: int = None, details: dict = None):
        """–õ–æ–≥–∏—Ä–æ–≤–∞–Ω–∏–µ —Å –∫—Ä–∞—Å–∏–≤—ã–º —Ñ–æ—Ä–º–∞—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ–º"""
        timestamp = datetime.now().strftime("%H:%M:%S")
        
        # –§–æ—Ä–º–∏—Ä—É–µ–º –æ—Å–Ω–æ–≤–Ω–æ–µ —Å–æ–æ–±—â–µ–Ω–∏–µ
        if user_id:
            base_msg = f"[{timestamp}] [{level}] ID {user_id}: {message}"
        else:
            base_msg = f"[{timestamp}] [{level}]: {message}"
        
        # –î–æ–±–∞–≤–ª—è–µ–º –¥–µ—Ç–∞–ª–∏
        if details:
            details_str = " | ".join([f"{k}={v}" for k, v in details.items() if v is not None])
            if details_str:
                base_msg += f" | {details_str}"
        
        # –õ–æ–≥–∏—Ä—É–µ–º –≤ —Ñ–∞–π–ª (–±–µ–∑ —Ü–≤–µ—Ç–æ–≤)
        if level == 'FOUND':
            self.logger.warning(base_msg)
        elif level == 'SUCCESS':
            self.logger.info(base_msg)
        else:
            getattr(self.logger, level.lower())(base_msg)
        
        # –ö—Ä–∞—Å–∏–≤—ã–π –≤—ã–≤–æ–¥ –≤ –∫–æ–Ω—Å–æ–ª—å
        color = self.colors.get(level, self.colors['RESET'])
        console_msg = f"{color}{base_msg}{self.colors['RESET']}"
        
        # –î–ª—è –ø—Ä–æ–≥—Ä–µ—Å—Å–∞ –∏ FOUND —Å–æ–æ–±—â–µ–Ω–∏–π - –Ω–æ–≤–∞—è —Å—Ç—Ä–æ–∫–∞
        if level in ['PROGRESS', 'FOUND', 'ERROR']:
            print(console_msg)
        else:
            # –î–ª—è –æ–±—ã—á–Ω—ã—Ö —Å–æ–æ–±—â–µ–Ω–∏–π - —Ç–æ–ª—å–∫–æ –µ—Å–ª–∏ –æ–Ω–∏ –≤–∞–∂–Ω—ã–µ
            if level in ['WARNING', 'SUCCESS'] or 'ERROR' in level:
                print(console_msg)

class ReliableUserSearch:
    def __init__(self):
        self.start_id = START_ID
        self.end_id = END_ID
        self.target_name = TARGET_NAME
        self.target_date = TARGET_DATE
        self.total_users = END_ID - START_ID + 1
        
        # –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è
        self.logger = SearchLogger()
        self.rate_limiter = RateLimiter(REQUESTS_PER_SECOND)
        
        # –°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞ –∏ —Å–æ—Å—Ç–æ—è–Ω–∏–µ
        self.found_users = []
        self.checked_ids = set()
        self.request_count = 0
        self.success_count = 0
        self.error_count = 0
        self.missing_ids = set()
        self.start_time = time.time()
        
        self.lock = threading.Lock()
        self.session = requests.Session()
        self.session.headers.update(HEADERS)
        
        # –î–µ—Ç–∞–ª—å–Ω–∞—è —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞ –æ—à–∏–±–æ–∫
        self.error_stats = defaultdict(int)
        self.error_codes = defaultdict(int)
        
        # –î–ª—è –∫–æ–Ω—Ç—Ä–æ–ª—è –æ—Å—Ç–∞–Ω–æ–≤–∫–∏
        self.should_stop = False
        signal.signal(signal.SIGINT, self.signal_handler)
        
        # –ó–∞–≥—Ä—É–∑–∫–∞ –ø—Ä–æ–≥—Ä–µ—Å—Å–∞
        if SAVE_PROGRESS:
            self.load_progress()
        
        self.show_header()
        self.print_expected_stats()
    
    def signal_handler(self, signum, frame):
        """–û–±—Ä–∞–±–æ—Ç—á–∏–∫ Ctrl+C"""
        self.logger.log('WARNING', "–ü–æ–ª—É—á–µ–Ω —Å–∏–≥–Ω–∞–ª –æ—Å—Ç–∞–Ω–æ–≤–∫–∏, –∑–∞–≤–µ—Ä—à–∞–µ–º...")
        self.should_stop = True
    
    def show_header(self):
        """–ö—Ä–∞—Å–∏–≤—ã–π –∑–∞–≥–æ–ª–æ–≤–æ–∫"""
        print("\n" + "=" * 80)
        print("üîç KLEINANZEIGEN –ü–û–ò–°–ö –ü–û–õ–¨–ó–û–í–ê–¢–ï–õ–Ø - –ù–ê–î–ï–ñ–ù–ê–Ø –í–ï–†–°–ò–Ø")
        print("=" * 80)
        print(f"üéØ –¶–µ–ª—å: '{self.target_name}'")
        print(f"üìä –î–∏–∞–ø–∞–∑–æ–Ω: {self.start_id:,} - {self.end_id:,}")
        print(f"üìà –í—Å–µ–≥–æ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π: {self.total_users:,}")
        print(f"‚ö° –°–∫–æ—Ä–æ—Å—Ç—å: {REQUESTS_PER_SECOND} –∑–∞–ø—Ä–æ—Å–æ–≤/—Å–µ–∫")
        print(f"üßµ –ü–æ—Ç–æ–∫–æ–≤: {MAX_WORKERS}")
        print("=" * 80)
        print("üìù –ü–æ–ª–Ω—ã–π –ª–æ–≥: search_complete.log")
        print("üíæ –ê–≤—Ç–æ—Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏–µ: search_progress.json")
        print("=" * 80 + "\n")
    
    def print_expected_stats(self):
        """–†–∞—Å—á–µ—Ç –æ–∂–∏–¥–∞–µ–º–æ–π –ø—Ä–æ–∏–∑–≤–æ–¥–∏—Ç–µ–ª—å–Ω–æ—Å—Ç–∏"""
        total_requests = self.total_users
        estimated_time = total_requests / REQUESTS_PER_SECOND
        
        self.logger.log('INFO', f"–†–ê–°–ß–ï–¢ –ü–†–û–ò–ó–í–û–î–ò–¢–ï–õ–¨–ù–û–°–¢–ò:")
        self.logger.log('INFO', f"  ‚Ä¢ –í—Å–µ–≥–æ –∑–∞–ø—Ä–æ—Å–æ–≤: {total_requests:,}")
        self.logger.log('INFO', f"  ‚Ä¢ –¶–µ–ª–µ–≤–∞—è —Å–∫–æ—Ä–æ—Å—Ç—å: {REQUESTS_PER_SECOND} –∑–∞–ø—Ä/—Å–µ–∫")
        
        if estimated_time < 60:
            self.logger.log('SUCCESS', f"  ‚Ä¢ –†–∞—Å—á–µ—Ç–Ω–æ–µ –≤—Ä–µ–º—è: {estimated_time:.1f} —Å–µ–∫—É–Ω–¥")
        elif estimated_time < 3600:
            minutes = estimated_time / 60
            self.logger.log('SUCCESS', f"  ‚Ä¢ –†–∞—Å—á–µ—Ç–Ω–æ–µ –≤—Ä–µ–º—è: {minutes:.1f} –º–∏–Ω—É—Ç")
        else:
            hours = estimated_time / 3600
            self.logger.log('SUCCESS', f"  ‚Ä¢ –†–∞—Å—á–µ—Ç–Ω–æ–µ –≤—Ä–µ–º—è: {hours:.1f} —á–∞—Å–æ–≤")
        
        print()
    
    def clean_name(self, name: str) -> str:
        """–û—á–∏—Å—Ç–∫–∞ –∏–º–µ–Ω–∏ –æ—Ç –ª–∏—à–Ω–∏—Ö –ø—Ä–æ–±–µ–ª–æ–≤"""
        if not name:
            return ""
        return re.sub(r'\s+', ' ', name.strip())
    
    def extract_name_from_html(self, html: str):
        """–ò–∑–≤–ª–µ—á–µ–Ω–∏–µ –∏–º–µ–Ω–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è –∏–∑ HTML"""
        try:
            # –û—Å–Ω–æ–≤–Ω–æ–π –ø–∞—Ç—Ç–µ—Ä–Ω
            pattern = r'<h2\s+class="userprofile--name">\s*<span\s+class="sr-only">Profil\s+von</span>\s*(.*?)\s*</h2>'
            match = re.search(pattern, html, re.DOTALL | re.IGNORECASE)
            
            if match:
                name = match.group(1).strip()
                name = re.sub(r'&[a-z]+;', ' ', name)
                return self.clean_name(name)
            
            # –ó–∞–ø–∞—Å–Ω–æ–π –ø–∞—Ç—Ç–µ—Ä–Ω
            pattern2 = r'"userprofile--name"[^>]*>.*?Profil von.*?>\s*(.*?)\s*<'
            match = re.search(pattern2, html, re.DOTALL | re.IGNORECASE)
            if match:
                name = match.group(1).strip()
                return self.clean_name(name)
            
            return None
        except Exception as e:
            self.logger.log('DEBUG', f"–û—à–∏–±–∫–∞ –ø–∞—Ä—Å–∏–Ω–≥–∞ –∏–º–µ–Ω–∏: {str(e)[:50]}")
            return None
    
    def is_exact_match(self, found_name: str) -> bool:
        """–ü—Ä–æ–≤–µ—Ä–∫–∞ —Ç–æ—á–Ω–æ–≥–æ —Å–æ–≤–ø–∞–¥–µ–Ω–∏—è –∏–º–µ–Ω–∏"""
        if not found_name:
            return False
        clean_found = self.clean_name(found_name).lower()
        clean_target = self.clean_name(self.target_name).lower()
        return clean_found == clean_target
    
    def fetch_user_page(self, user_id: int):
        """–ü–æ–ª—É—á–µ–Ω–∏–µ —Å—Ç—Ä–∞–Ω–∏—Ü—ã –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è —Å –∫–æ–Ω—Ç—Ä–æ–ª–µ–º —Å–∫–æ—Ä–æ—Å—Ç–∏"""
        # –ö–æ–Ω—Ç—Ä–æ–ª—å —Å–∫–æ—Ä–æ—Å—Ç–∏
        self.rate_limiter.wait()
        
        url = BASE_URL.format(user_id=user_id)
        
        try:
            response = self.session.get(url, timeout=TIMEOUT)
            
            with self.lock:
                self.request_count += 1
                self.success_count += 1
            
            return {
                'success': True,
                'status_code': response.status_code,
                'html': response.text if response.status_code == 200 else None,
                'error': None
            }
            
        except requests.exceptions.Timeout:
            with self.lock:
                self.request_count += 1
                self.error_count += 1
                self.error_stats['timeout'] += 1
            
            return {
                'success': False,
                'status_code': None,
                'html': None,
                'error': 'timeout'
            }
            
        except requests.exceptions.ConnectionError:
            with self.lock:
                self.request_count += 1
                self.error_count += 1
                self.error_stats['connection'] += 1
            
            return {
                'success': False,
                'status_code': None,
                'html': None,
                'error': 'connection'
            }
            
        except Exception as e:
            with self.lock:
                self.request_count += 1
                self.error_count += 1
                self.error_stats['other'] += 1
            
            return {
                'success': False,
                'status_code': None,
                'html': None,
                'error': f'other: {str(e)[:50]}'
            }
    
    def process_user(self, user_id: int):
        """–û–±—Ä–∞–±–æ—Ç–∫–∞ –æ–¥–Ω–æ–≥–æ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è"""
        if self.should_stop:
            return None
        
        # –ü–æ–ª—É—á–∞–µ–º —Å—Ç—Ä–∞–Ω–∏—Ü—É
        result = self.fetch_user_page(user_id)
        
        # –õ–æ–≥–∏—Ä—É–µ–º –í–°–ï —Ä–µ–∑—É–ª—å—Ç–∞—Ç—ã
        if result['success']:
            if result['status_code'] == 200:
                # –ü–∞—Ä—Å–∏–º –∏–º—è
                name = self.extract_name_from_html(result['html'])
                
                if name:
                    # –ü—Ä–æ–≤–µ—Ä—è–µ–º –Ω–∞ —Å–æ–≤–ø–∞–¥–µ–Ω–∏–µ
                    if self.is_exact_match(name):
                        user_data = {
                            'id': user_id,
                            'name': name,
                            'url': BASE_URL.format(user_id=user_id),
                            'timestamp': datetime.now().isoformat()
                        }
                        
                        with self.lock:
                            self.found_users.append(user_data)
                        
                        # ===== –Ø–í–ù–û–ï –û–ü–û–í–ï–©–ï–ù–ò–ï –û –ù–ê–•–û–ñ–î–ï–ù–ò–ò –¶–ï–õ–ï–í–û–ì–û –ü–û–õ–¨–ó–û–í–ê–¢–ï–õ–Ø =====
                        print("\n" + "‚≠ê" * 70)
                        print("‚≠ê" * 25 + " –ù–ê–ô–î–ï–ù –¶–ï–õ–ï–í–û–ô –ü–û–õ–¨–ó–û–í–ê–¢–ï–õ–¨! " + "‚≠ê" * 25)
                        print("‚≠ê" * 70)
                        print(f"‚≠ê ID: {user_id}")
                        print(f"‚≠ê –ò–ú–Ø: {name}")
                        print(f"‚≠ê –°–°–´–õ–ö–ê: {BASE_URL.format(user_id=user_id)}")
                        print(f"‚≠ê –í–†–ï–ú–Ø: {datetime.now().strftime('%H:%M:%S')}")
                        print("‚≠ê" * 70)
                        print("‚≠ê –°–∫—Ä–∏–ø—Ç –ø—Ä–æ–¥–æ–ª–∂–∏—Ç —Ä–∞–±–æ—Ç—É –¥–ª—è –ø–æ–∏—Å–∫–∞ –¥—Ä—É–≥–∏—Ö —Å–æ–≤–ø–∞–¥–µ–Ω–∏–π")
                        print("‚≠ê" * 70 + "\n")
                        
                        # –°—Ç–∞–Ω–¥–∞—Ä—Ç–Ω–æ–µ –ª–æ–≥–∏—Ä–æ–≤–∞–Ω–∏–µ
                        self.logger.log('FOUND', f"–ù–ê–ô–î–ï–ù –ü–û–õ–¨–ó–û–í–ê–¢–ï–õ–¨!", user_id, 
                                      {'name': name, 'status': 'FOUND'})
                        return user_data
                    
                    # –û–±—ã—á–Ω—ã–π –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å
                    self.logger.log('INFO', "–ü—Ä–æ–≤–µ—Ä–µ–Ω", user_id, {'name': name})
                else:
                    # –°—Ç—Ä–∞–Ω–∏—Ü–∞ –µ—Å—Ç—å, –Ω–æ –∏–º—è –Ω–µ –Ω–∞–π–¥–µ–Ω–æ
                    self.logger.log('DEBUG', "–ò–º—è –Ω–µ –Ω–∞–π–¥–µ–Ω–æ –≤ HTML", user_id)
            else:
                # HTTP –æ—à–∏–±–∫–∞
                with self.lock:
                    self.error_codes[result['status_code']] += 1
                
                self.logger.log('ERROR', f"HTTP –æ—à–∏–±–∫–∞", user_id, 
                              {'status': result['status_code']})
        else:
            # –û—à–∏–±–∫–∞ —Å–µ—Ç–∏/—Ç–∞–π–º–∞—É—Ç
            self.logger.log('ERROR', f"–û—à–∏–±–∫–∞ –∑–∞–ø—Ä–æ—Å–∞", user_id, {'error': result['error']})
        
        return None
    
    def print_progress(self):
        """–ö—Ä–∞—Å–∏–≤—ã–π –≤—ã–≤–æ–¥ –ø—Ä–æ–≥—Ä–µ—Å—Å–∞"""
        with self.lock:
            checked = len(self.checked_ids)
            requests = self.request_count
            errors = self.error_count
            found = len(self.found_users)
        
        # –†–∞—Å—á–µ—Ç—ã
        elapsed = time.time() - self.start_time
        progress_pct = (checked / self.total_users * 100) if self.total_users > 0 else 0
        
        if elapsed > 0:
            speed = requests / elapsed
        else:
            speed = 0
        
        # –†–∞—Å—á–µ—Ç –æ—Å—Ç–∞–≤—à–µ–≥–æ—Å—è –≤—Ä–µ–º–µ–Ω–∏
        if speed > 0 and checked < self.total_users:
            remaining = self.total_users - checked
            eta_seconds = remaining / speed
            
            if eta_seconds < 60:
                eta_str = f"{eta_seconds:.0f}—Å"
            elif eta_seconds < 3600:
                eta_str = f"{eta_seconds/60:.0f}–º"
            else:
                eta_str = f"{eta_seconds/3600:.1f}—á"
        else:
            eta_str = "---"
        
        # –§–æ—Ä–º–∞—Ç–∏—Ä–æ–≤–∞–Ω–Ω–∞—è —Å—Ç—Ä–æ–∫–∞ –ø—Ä–æ–≥—Ä–µ—Å—Å–∞
        progress_line = (
            f"[{datetime.now().strftime('%H:%M:%S')}] "
            f"[PROGRESS] –ü—Ä–æ–≤–µ—Ä–µ–Ω–æ: {checked:,}/{self.total_users:,} ({progress_pct:.1f}%) | "
            f"–°–∫–æ—Ä–æ—Å—Ç—å: {speed:.1f} –∑–∞–ø—Ä/—Å–µ–∫ | "
            f"–û—Å—Ç–∞–ª–æ—Å—å: {eta_str} | "
            f"–ù–∞–π–¥–µ–Ω–æ: {found} | "
            f"–û—à–∏–±–æ–∫: {errors:,}"
        )
        
        # –¶–≤–µ—Ç –¥–ª—è –ø—Ä–æ–≥—Ä–µ—Å—Å–∞
        if progress_pct < 30:
            color = '\033[91m'  # –ö—Ä–∞—Å–Ω—ã–π
        elif progress_pct < 70:
            color = '\033[93m'  # –ñ–µ–ª—Ç—ã–π
        else:
            color = '\033[92m'  # –ó–µ–ª–µ–Ω—ã–π
        
        print(f"{color}{progress_line}\033[0m", end='\r')
    
    def search_batch(self, batch_ids):
        """–ü–æ–∏—Å–∫ –≤ –ø–∞–∫–µ—Ç–µ ID"""
        with ThreadPoolExecutor(max_workers=MAX_WORKERS) as executor:
            future_to_id = {executor.submit(self.process_user, user_id): user_id 
                          for user_id in batch_ids}
            
            for future in as_completed(future_to_id):
                user_id = future_to_id[future]
                
                try:
                    future.result(timeout=TIMEOUT + 5)
                except Exception as e:
                    self.logger.log('ERROR', f"–û—à–∏–±–∫–∞ –æ–±—Ä–∞–±–æ—Ç–∫–∏", user_id, 
                                  {'error': str(e)[:50]})
                
                with self.lock:
                    self.checked_ids.add(user_id)
                
                # –ü–æ–∫–∞–∑—ã–≤–∞–µ–º –ø—Ä–æ–≥—Ä–µ—Å—Å –∫–∞–∂–¥—ã–µ 5 –ø—Ä–æ–≤–µ—Ä–æ–∫
                if len(self.checked_ids) % 5 == 0:
                    self.print_progress()
    
    def run_search(self):
        """–û—Å–Ω–æ–≤–Ω–æ–π –º–µ—Ç–æ–¥ –ø–æ–∏—Å–∫–∞"""
        self.logger.log('INFO', "üöÄ –ó–ê–ü–£–°–ö –ü–û–ò–°–ö–ê...")
        self.logger.log('INFO', f"–ù–∞–∂–º–∏—Ç–µ Ctrl+C –¥–ª—è –±–µ–∑–æ–ø–∞—Å–Ω–æ–π –æ—Å—Ç–∞–Ω–æ–≤–∫–∏")
        print()
        
        # –ù–∞—á–∞–ª—å–Ω—ã–π –≤—ã–≤–æ–¥ –ø—Ä–æ–≥—Ä–µ—Å—Å–∞
        self.print_progress()
        
        # –†–∞–∑–±–∏–≤–∞–µ–º –Ω–∞ –ø–∞–∫–µ—Ç—ã
        all_ids = range(self.start_id, self.end_id + 1)
        total_batches = (self.total_users + BATCH_SIZE - 1) // BATCH_SIZE
        
        for batch_num in range(total_batches):
            if self.should_stop:
                self.logger.log('WARNING', "–ü–æ–∏—Å–∫ –æ—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–º")
                break
            
            start_idx = batch_num * BATCH_SIZE
            end_idx = min((batch_num + 1) * BATCH_SIZE, self.total_users)
            batch_ids = list(all_ids[start_idx:end_idx])
            
            batch_start = time.time()
            self.search_batch(batch_ids)
            batch_time = time.time() - batch_start
            
            # –°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞ –ø–∞–∫–µ—Ç–∞
            if batch_time > 0 and len(batch_ids) > 0:
                batch_speed = len(batch_ids) / batch_time
                self.logger.log('DEBUG', f"–ü–∞–∫–µ—Ç {batch_num+1}/{total_batches} –∑–∞–≤–µ—Ä—à–µ–Ω", 
                              None, {'–≤—Ä–µ–º—è': f"{batch_time:.1f}—Å", '—Å–∫–æ—Ä–æ—Å—Ç—å': f"{batch_speed:.1f} –∑–∞–ø—Ä/—Å–µ–∫"})
            
            # –°–æ—Ö—Ä–∞–Ω—è–µ–º –ø—Ä–æ–≥—Ä–µ—Å—Å –∫–∞–∂–¥—ã–µ 5 –ø–∞–∫–µ—Ç–æ–≤
            if SAVE_PROGRESS and batch_num % 5 == 0:
                self.save_progress()
            
            # –ù–µ–±–æ–ª—å—à–∞—è –ø–∞—É–∑–∞ –º–µ–∂–¥—É –ø–∞–∫–µ—Ç–∞–º–∏
            if batch_num < total_batches - 1 and not self.should_stop:
                time.sleep(0.3)
        
        # –§–∏–Ω–∞–ª—å–Ω—ã–π –ø—Ä–æ–≥—Ä–µ—Å—Å
        self.print_progress()
        print("\n")
        
        # –ü—Ä–æ–≤–µ—Ä—è–µ–º –ø—Ä–æ–ø—É—â–µ–Ω–Ω—ã–µ ID
        self.check_missing_ids()
        
        return self.found_users
    
    def check_missing_ids(self):
        """–ü—Ä–æ–≤–µ—Ä–∫–∞ –ø—Ä–æ–ø—É—â–µ–Ω–Ω—ã—Ö ID"""
        expected_ids = set(range(self.start_id, self.end_id + 1))
        missing_ids = expected_ids - self.checked_ids
        
        if missing_ids:
            self.missing_ids = missing_ids
            self.logger.log('WARNING', f"–û–±–Ω–∞—Ä—É–∂–µ–Ω—ã –ø—Ä–æ–ø—É—â–µ–Ω–Ω—ã–µ ID: {len(missing_ids)}")
            
            # –õ–æ–≥–∏—Ä—É–µ–º –ø–µ—Ä–≤—ã–µ 10 –ø—Ä–æ–ø—É—â–µ–Ω–Ω—ã—Ö ID
            first_missing = sorted(missing_ids)[:10]
            for mid in first_missing:
                self.logger.log('DEBUG', f"–ü—Ä–æ–ø—É—â–µ–Ω ID", mid)
            
            if len(missing_ids) > 10:
                self.logger.log('DEBUG', f"... –∏ –µ—â–µ {len(missing_ids) - 10} ID")
    
    def save_progress(self):
        """–°–æ—Ö—Ä–∞–Ω–µ–Ω–∏–µ –ø—Ä–æ–≥—Ä–µ—Å—Å–∞"""
        if not SAVE_PROGRESS:
            return
        
        with self.lock:
            data = {
                'search_config': {
                    'start_id': self.start_id,
                    'end_id': self.end_id,
                    'target_name': self.target_name,
                    'target_date': self.target_date,
                },
                'progress': {
                    'checked_ids': sorted(list(self.checked_ids)),
                    'last_check_time': datetime.now().isoformat(),
                    'total_checked': len(self.checked_ids),
                },
                'results': {
                    'found_users': self.found_users,
                    'total_found': len(self.found_users),
                },
                'statistics': {
                    'requests': self.request_count,
                    'success': self.success_count,
                    'errors': self.error_count,
                    'error_stats': dict(self.error_stats),
                    'error_codes': dict(self.error_codes),
                },
                'missing_ids': sorted(list(self.missing_ids)),
            }
        
        try:
            with open(PROGRESS_FILE, 'w', encoding='utf-8') as f:
                json.dump(data, f, ensure_ascii=False, indent=2)
            
            self.logger.log('SUCCESS', "–ü—Ä–æ–≥—Ä–µ—Å—Å —Å–æ—Ö—Ä–∞–Ω–µ–Ω")
        except Exception as e:
            self.logger.log('ERROR', f"–û—à–∏–±–∫–∞ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏—è –ø—Ä–æ–≥—Ä–µ—Å—Å–∞", None, {'error': str(e)})
    
    def load_progress(self):
        """–ó–∞–≥—Ä—É–∑–∫–∞ –ø—Ä–æ–≥—Ä–µ—Å—Å–∞"""
        try:
            with open(PROGRESS_FILE, 'r', encoding='utf-8') as f:
                data = json.load(f)
            
            config = data.get('search_config', {})
            if (config.get('start_id') == self.start_id and 
                config.get('end_id') == self.end_id and
                config.get('target_name') == self.target_name):
                
                progress = data.get('progress', {})
                self.checked_ids = set(progress.get('checked_ids', []))
                
                results = data.get('results', {})
                self.found_users = results.get('found_users', [])
                
                stats = data.get('statistics', {})
                self.request_count = stats.get('requests', 0)
                self.success_count = stats.get('success', 0)
                self.error_count = stats.get('errors', 0)
                
                missing = data.get('missing_ids', [])
                self.missing_ids = set(missing)
                
                self.logger.log('SUCCESS', f"–ó–∞–≥—Ä—É–∂–µ–Ω –ø—Ä–æ–≥—Ä–µ—Å—Å: {len(self.checked_ids):,} –ø—Ä–æ–≤–µ—Ä–µ–Ω–Ω—ã—Ö")
                self.logger.log('SUCCESS', f"–£–∂–µ –Ω–∞–π–¥–µ–Ω–æ: {len(self.found_users)} –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π")
                
                if self.missing_ids:
                    self.logger.log('WARNING', f"–ï—Å—Ç—å –ø—Ä–æ–ø—É—â–µ–Ω–Ω—ã–µ ID: {len(self.missing_ids)}")
                
        except FileNotFoundError:
            self.logger.log('INFO', "–ü—Ä–æ–≥—Ä–µ—Å—Å –Ω–µ –Ω–∞–π–¥–µ–Ω, –Ω–∞—á–∏–Ω–∞–µ–º —Å –Ω–∞—á–∞–ª–∞")
        except Exception as e:
            self.logger.log('ERROR', f"–û—à–∏–±–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∏ –ø—Ä–æ–≥—Ä–µ—Å—Å–∞", None, {'error': str(e)})
    
    def print_final_report(self):
        """–ö—Ä–∞—Å–∏–≤—ã–π —Ñ–∏–Ω–∞–ª—å–Ω—ã–π –æ—Ç—á–µ—Ç —Å –≤—ã–¥–µ–ª–µ–Ω–∏–µ–º –Ω–∞–π–¥–µ–Ω–Ω—ã—Ö –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π"""
        print("\n" + "=" * 80)
        print("üìä –§–ò–ù–ê–õ–¨–ù–´–ô –û–¢–ß–ï–¢ –ü–û–ò–°–ö–ê")
        print("=" * 80)
        
        elapsed = time.time() - self.start_time
        
        with self.lock:
            checked = len(self.checked_ids)
            requests = self.request_count
            errors = self.error_count
            found = len(self.found_users)
            missing = len(self.missing_ids)
        
        # –í—Ä–µ–º—è
        if elapsed < 60:
            time_str = f"{elapsed:.1f} —Å–µ–∫—É–Ω–¥"
        elif elapsed < 3600:
            time_str = f"{elapsed/60:.1f} –º–∏–Ω—É—Ç"
        else:
            time_str = f"{elapsed/3600:.1f} —á–∞—Å–æ–≤"
        
        print(f"\n‚è±Ô∏è  –û–ë–©–ï–ï –í–†–ï–ú–Ø: {time_str}")
        print(f"üìä –ü–†–û–í–ï–†–ï–ù–û: {checked:,}/{self.total_users:,} –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π")
        
        if elapsed > 0:
            avg_speed = requests / elapsed
            print(f"‚ö° –°–†–ï–î–ù–Ø–Ø –°–ö–û–†–û–°–¢–¨: {avg_speed:.1f} –∑–∞–ø—Ä–æ—Å–æ–≤/—Å–µ–∫")
        
        print(f"‚úÖ –£–°–ü–ï–®–ù–´–• –ó–ê–ü–†–û–°–û–í: {self.success_count:,}")
        print(f"‚ùå –û–®–ò–ë–û–ö: {errors:,}")
        
        # –°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞ –æ—à–∏–±–æ–∫
        if self.error_stats:
            print(f"\nüîß –°–¢–ê–¢–ò–°–¢–ò–ö–ê –û–®–ò–ë–û–ö:")
            for error_type, count in sorted(self.error_stats.items()):
                if count > 0:
                    percentage = (count / errors * 100) if errors > 0 else 0
                    print(f"   ‚Ä¢ {error_type}: {count:,} ({percentage:.1f}%)")
        
        # HTTP –∫–æ–¥—ã –æ—à–∏–±–æ–∫
        if self.error_codes:
            print(f"\nüì° HTTP –°–¢–ê–¢–£–°–´:")
            for code, count in sorted(self.error_codes.items()):
                print(f"   ‚Ä¢ {code}: {count:,}")
        
        # –ü—Ä–æ–ø—É—â–µ–Ω–Ω—ã–µ ID
        if missing > 0:
            print(f"\n‚ö†Ô∏è  –ü–†–û–ü–£–©–ï–ù–û ID: {missing:,}")
            if missing <= 20:
                print(f"   ID: {sorted(self.missing_ids)}")
        
        # –†–ï–ó–£–õ–¨–¢–ê–¢–´ –° –Ø–í–ù–´–ú –í–´–î–ï–õ–ï–ù–ò–ï–ú
        print(f"\n" + "-" * 40)
        print("üéØ –†–ï–ó–£–õ–¨–¢–ê–¢–´ –ü–û–ò–°–ö–ê:")
        
        if found > 0:
            print(f"\n" + "üéØ" * 40)
            print(f"üéØ –ù–ê–ô–î–ï–ù–û –¶–ï–õ–ï–í–´–• –ü–û–õ–¨–ó–û–í–ê–¢–ï–õ–ï–ô: {found}")
            print("üéØ" * 40)
            
            for user in self.found_users:
                print(f"\n   ‚≠ê ID: {user['id']}")
                print(f"   ‚≠ê –ò–º—è: {user['name']}")
                print(f"   ‚≠ê –°—Å—ã–ª–∫–∞: {user['url']}")
                print(f"   ‚≠ê –í—Ä–µ–º—è –Ω–∞—Ö–æ–¥–∫–∏: {user['timestamp'][11:19]}")
                print(f"   {'‚îÄ' * 40}")
        else:
            print(f"\n‚ùå –ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å '{self.target_name}' –Ω–µ –Ω–∞–π–¥–µ–Ω")
            print(f"   –≤ –¥–∏–∞–ø–∞–∑–æ–Ω–µ {self.start_id:,} - {self.end_id:,}")
        
        print(f"\n" + "=" * 80)
        print(f"üìÅ –õ–æ–≥ —Å–æ—Ö—Ä–∞–Ω–µ–Ω: {LOG_FILE}")
        if SAVE_PROGRESS:
            print(f"üíæ –ü—Ä–æ–≥—Ä–µ—Å—Å —Å–æ—Ö—Ä–∞–Ω–µ–Ω: {PROGRESS_FILE}")
        print("=" * 80)

def main():
    """–û—Å–Ω–æ–≤–Ω–∞—è —Ñ—É–Ω–∫—Ü–∏—è"""
    # –ü—Ä–æ–≤–µ—Ä–∫–∞ –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏–∏
    if START_ID > END_ID:
        print("‚ùå –û—à–∏–±–∫–∞: START_ID –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å –º–µ–Ω—å—à–µ END_ID")
        return
    
    if not TARGET_NAME or TARGET_NAME.strip() == "":
        print("‚ùå –û—à–∏–±–∫–∞: TARGET_NAME –Ω–µ –º–æ–∂–µ—Ç –±—ã—Ç—å –ø—É—Å—Ç—ã–º")
        return
    
    print("\n" + "‚ú®" * 40)
    print("‚ú®      KLEINANZEIGEN –ü–û–ò–°–ö –ü–û–õ–¨–ó–û–í–ê–¢–ï–õ–Ø      ‚ú®")
    print("‚ú®" * 40 + "\n")
    
    try:
        # –°–æ–∑–¥–∞–µ–º –ø–æ–∏—Å–∫
        search = ReliableUserSearch()
        
        # –ó–∞–ø—É—Å–∫–∞–µ–º –ø–æ–∏—Å–∫
        found = search.run_search()
        
        # –°–æ—Ö—Ä–∞–Ω—è–µ–º —Ñ–∏–Ω–∞–ª—å–Ω—ã–π –ø—Ä–æ–≥—Ä–µ—Å—Å
        if SAVE_PROGRESS:
            search.save_progress()
        
        # –í—ã–≤–æ–¥–∏–º –æ—Ç—á–µ—Ç
        search.print_final_report()
        
        # –ü—Ä–µ–¥–ª–æ–∂–µ–Ω–∏–µ –ø—Ä–æ–≤–µ—Ä–∏—Ç—å –ø—Ä–æ–ø—É—â–µ–Ω–Ω—ã–µ ID
        if search.missing_ids:
            print(f"\n‚ö†Ô∏è  –•–æ—Ç–∏—Ç–µ –ø—Ä–æ–≤–µ—Ä–∏—Ç—å –ø—Ä–æ–ø—É—â–µ–Ω–Ω—ã–µ ID?")
            print(f"   –ó–∞–ø—É—Å—Ç–∏—Ç–µ: python check_missing.py")
        
    except KeyboardInterrupt:
        print("\n\nüõë –ü–û–ò–°–ö –ü–†–ï–†–í–ê–ù –ü–û–õ–¨–ó–û–í–ê–¢–ï–õ–ï–ú")
        if 'search' in locals():
            if SAVE_PROGRESS:
                search.save_progress()
            search.print_final_report()
    except Exception as e:
        print(f"\nüí• –ö–†–ò–¢–ò–ß–ï–°–ö–ê–Ø –û–®–ò–ë–ö–ê: {e}")
        import traceback
        traceback.print_exc()

if __name__ == "__main__":
    main()
